import { Problem } from '../../types';

export const DM_13_DETERMINANT_OF_A_4X4_MATRIX_USING_LAPLACE_S_EXPANSION: Problem = {
  "id": "dm_13_determinant_of_a_4x4_matrix_using_laplaces_expansion",
  "title": "Determinant of a 4x4 Matrix using Laplace's Expansion",
  "difficulty": "Hard",
  "tags": [
    "Linear Algebra",
    "Matrix Operations"
  ],
  "descriptionMarkdown": "Write a Python function that calculates the determinant of a 4x4 matrix using Laplace's Expansion (cofactor expansion). The function should:\n\n- Take a single argument: a 4x4 matrix represented as a list of lists (elements can be integers or floats).\n- Compute the determinant by expanding along a row or column and recursively evaluating determinants of minor matrices (down to 3x3 and smaller).\n- Return the determinant as a floating-point number.\n\nExample:\n\nInput:\n\n```\na = [[1,2,3,4],\n     [5,6,7,8],\n     [9,10,11,12],\n     [13,14,15,16]]\n```\n\nOutput reasoning:\n\nUsing Laplace's Expansion, this specific matrix is rank-deficient, so its determinant is 0. For a generic 4x4 matrix, compute the determinant by expanding into minors and cofactors, recursively evaluating the determinants of 3x3 matrices.",
  "solutionExplanation": "Laplace's expansion expresses the determinant of an n\u00d7n matrix as a sum of cofactors along any chosen row or column. Expanding along the first row, det(A) = \u03a3_j (-1)^(0+j) * A[0, j] * det(M_0j), where M_0j is the (n-1)\u00d7(n-1) minor formed by removing row 0 and column j. Recursively applying this procedure reduces the problem to computing determinants of smaller matrices until reaching the 2\u00d72 (or 1\u00d71) base case.\n\nIn the provided solution, we implement a general recursive determinant function using PyTorch tensors. We create minors with boolean masks to remove the selected row and column efficiently. The base cases are 1\u00d71 and 2\u00d72 determinants. Although PyTorch provides built-in determinant routines, we implement the algorithm explicitly to adhere to the Laplace expansion requirement and to demonstrate the recursive structure.\n\nFor the example matrix, the rows are linearly dependent (each row is an arithmetic progression with constant differences), yielding a determinant of 0. The recursive approach works for any 4\u00d74 input and can be generalized to n\u00d7n, though it becomes computationally expensive for large n.",
  "solutionCode": "import torch\nfrom typing import List, Union\n\nNumber = Union[int, float]\n\n\ndef _minor(M: torch.Tensor, i: int, j: int) -> torch.Tensor:\n    \"\"\"Return the (n-1)x(n-1) minor of M obtained by removing row i and column j.\"\"\"\n    n = M.size(0)\n    row_mask = torch.ones(n, dtype=torch.bool, device=M.device)\n    col_mask = torch.ones(n, dtype=torch.bool, device=M.device)\n    row_mask[i] = False\n    col_mask[j] = False\n    return M[row_mask][:, col_mask]\n\n\ndef _det_recursive(M: torch.Tensor) -> torch.Tensor:\n    \"\"\"Compute determinant of a square matrix M via Laplace expansion (recursive).\"\"\"\n    assert M.ndim == 2 and M.size(0) == M.size(1), \"Input must be a square matrix\"\n    n = M.size(0)\n\n    if n == 1:\n        return M[0, 0]\n    if n == 2:\n        return M[0, 0] * M[1, 1] - M[0, 1] * M[1, 0]\n\n    det = M.new_zeros(())  # scalar tensor\n    # Expand along the first row for simplicity\n    for j in range(n):\n        sign = -1.0 if (j % 2 == 1) else 1.0  # (-1)^(0+j)\n        sub = _minor(M, 0, j)\n        det = det + sign * M[0, j] * _det_recursive(sub)\n    return det\n\n\ndef determinant_4x4(matrix: List[List[Number]]) -> float:\n    \"\"\"\n    Compute the determinant of a 4x4 matrix using Laplace's expansion.\n\n    Args:\n        matrix: A 4x4 list of lists containing ints or floats.\n    Returns:\n        Determinant as a Python float.\n    \"\"\"\n    # Convert to a torch tensor for computation\n    M = torch.tensor(matrix, dtype=torch.double)\n    if M.ndim != 2 or M.size(0) != 4 or M.size(1) != 4:\n        raise ValueError(\"Input must be a 4x4 matrix (list of lists)\")\n    det = _det_recursive(M)\n    return float(det.item())\n\n\nif __name__ == \"__main__\":\n    # Example usage\n    a = [[1, 2, 3, 4],\n         [5, 6, 7, 8],\n         [9, 10, 11, 12],\n         [13, 14, 15, 16]]\n    print(determinant_4x4(a))  # Expected: 0.0\n",
  "timeComplexity": "O(n!) for an n\u00d7n matrix (constant for fixed 4\u00d74)",
  "spaceComplexity": "O(n^2) due to storing minors along the recursion (O(1) for fixed 4\u00d74)",
  "platform": "deepml"
};
