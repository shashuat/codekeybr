import { Problem } from '../../types';

export const DM_29_RANDOM_SHUFFLE_OF_DATASET: Problem = {
  "id": "dm_29_random_shuffle_of_dataset",
  "title": "Random Shuffle of Dataset",
  "difficulty": "Easy",
  "tags": [
    "Probability",
    "Matrix Operations"
  ],
  "descriptionMarkdown": "Write a function that randomly shuffles two aligned datasets X and y while preserving the correspondence between each sample in X and its label (or target) in y. The function should accept an optional seed parameter to make the shuffle reproducible.\n\nExample\n- Input:\n  - X = [[1, 2], [3, 4], [5, 6], [7, 8]]\n  - y = [1, 2, 3, 4]\n- Possible Output:\n  - X' = [[5, 6], [1, 2], [7, 8], [3, 4]]\n  - y' = [3, 1, 4, 2]\n\nThe same random permutation must be applied to both X and y.",
  "solutionExplanation": "To shuffle two aligned datasets consistently, we generate a single random permutation of indices and apply it to both X and y. This guarantees that the i-th row of X is always paired with the i-th element (or row) of y after shuffling. In PyTorch, we can obtain such a permutation via torch.randperm.\n\nFor reproducibility, we avoid modifying global RNG state by using a local torch.Generator initialized with the provided seed. This yields deterministic permutations for a given seed while leaving other parts of the program's randomness unaffected. The implementation supports both PyTorch tensors and NumPy arrays by converting inputs to torch.Tensors internally and, if the original inputs were NumPy arrays, converting the outputs back to NumPy arrays.",
  "solutionCode": "import torch\nfrom typing import Tuple, Union\n\ntry:\n    import numpy as np  # Optional, only used if inputs are NumPy arrays\n    _NP_AVAILABLE = True\nexcept Exception:\n    np = None\n    _NP_AVAILABLE = False\n\nTensorOrArray = Union[torch.Tensor, 'np.ndarray']\n\n\ndef shuffle_data(X: TensorOrArray, y: TensorOrArray, seed: Union[int, None] = None) -> Tuple[TensorOrArray, TensorOrArray]:\n    \"\"\"\n    Randomly shuffle X and y with a shared permutation, preserving correspondence.\n\n    Args:\n        X: Feature matrix as a torch.Tensor or NumPy ndarray, shape (N, ...).\n        y: Target vector/matrix as a torch.Tensor or NumPy ndarray, shape (N, ...).\n        seed: Optional integer seed for reproducibility. If None, uses non-deterministic RNG.\n\n    Returns:\n        (X_shuffled, y_shuffled) in the same types as provided (torch.Tensor or np.ndarray).\n\n    Raises:\n        ValueError: If first dimension lengths of X and y do not match or inputs are invalid.\n    \"\"\"\n    # Track original types to return in the same form\n    x_is_numpy = _NP_AVAILABLE and isinstance(X, np.ndarray)\n    y_is_numpy = _NP_AVAILABLE and isinstance(y, np.ndarray)\n\n    # Convert inputs to torch tensors (zero-copy when possible)\n    X_t = torch.as_tensor(X)\n    y_t = torch.as_tensor(y)\n\n    if X_t.dim() == 0 or y_t.dim() == 0:\n        raise ValueError(\"X and y must have at least one dimension with batch size in dim 0.\")\n\n    n_x = X_t.shape[0]\n    n_y = y_t.shape[0]\n    if n_x != n_y:\n        raise ValueError(f\"Mismatched number of samples: X has {n_x}, y has {n_y}.\")\n\n    # Local generator for reproducibility without affecting global RNG state\n    g = torch.Generator(device=X_t.device)\n    if seed is not None:\n        g.manual_seed(int(seed))\n\n    # Generate a random permutation of indices and apply to both tensors\n    perm = torch.randperm(n_x, generator=g, device=X_t.device)\n    X_shuffled_t = X_t.index_select(dim=0, index=perm)\n    y_shuffled_t = y_t.index_select(dim=0, index=perm)\n\n    # Return in the same types as input\n    if x_is_numpy:\n        X_shuffled = X_shuffled_t.cpu().numpy()\n    else:\n        X_shuffled = X_shuffled_t\n\n    if y_is_numpy:\n        y_shuffled = y_shuffled_t.cpu().numpy()\n    else:\n        y_shuffled = y_shuffled_t\n\n    return X_shuffled, y_shuffled\n\n\ndef solution():\n    \"\"\"Demonstration of shuffle_data using PyTorch tensors.\"\"\"\n    # Example with PyTorch tensors\n    X = torch.tensor([[1, 2], [3, 4], [5, 6], [7, 8]])\n    y = torch.tensor([1, 2, 3, 4])\n\n    X_shuf, y_shuf = shuffle_data(X, y, seed=42)\n\n    # Example with NumPy arrays (if NumPy is available)\n    if _NP_AVAILABLE:\n        X_np = np.array([[1, 2], [3, 4], [5, 6], [7, 8]])\n        y_np = np.array([1, 2, 3, 4])\n        X_shuf_np, y_shuf_np = shuffle_data(X_np, y_np, seed=42)\n        return (X_shuf, y_shuf, X_shuf_np, y_shuf_np)\n\n    return (X_shuf, y_shuf)\n",
  "timeComplexity": "O(N)",
  "spaceComplexity": "O(N)",
  "platform": "deepml"
};
