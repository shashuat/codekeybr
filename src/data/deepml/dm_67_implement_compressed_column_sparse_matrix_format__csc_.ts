import { Problem } from '../../types';

export const DM_67_IMPLEMENT_COMPRESSED_COLUMN_SPARSE_MATRIX_FORMAT__CSC_: Problem = {
  "id": "dm_67_implement_compressed_column_sparse_matrix_format_csc",
  "title": "Implement Compressed Column Sparse Matrix Format (CSC)",
  "difficulty": "Easy",
  "tags": [
    "Linear Algebra",
    "Matrix Operations"
  ],
  "descriptionMarkdown": "Task: Create a Compressed Column Sparse (CSC) representation\n\nImplement a function compressed_col_sparse_matrix(dense_matrix) that converts a 2D dense matrix (as a list of lists) into its CSC representation. The CSC format stores only non-zero elements and is efficient for sparse matrices.\n\nReturn a tuple of three lists:\n- values: Non-zero elements in column-major order\n- row indices: The row index for each value in values\n- column pointer: Starting index in values for each column (length = num_columns + 1)\n\nExample:\n\nInput:\n\ndense_matrix = [\n  [0, 0, 3, 0],\n  [1, 0, 0, 4],\n  [0, 2, 0, 0]\n]\n\nOutput:\n\nvalues = [1, 2, 3, 4]\nrow_idx = [1, 2, 0, 1]\ncol_ptr = [0, 1, 2, 3, 4]",
  "solutionExplanation": "The Compressed Column Sparse (CSC) format stores a matrix using three arrays: values, row indices, and column pointer. The values array contains all non-zero entries traversed column by column. The row indices array stores the corresponding row index for each value. The column pointer array has length n_cols + 1 and indicates, for each column, the starting index of that column's data in the values array; the final entry equals the total number of non-zero elements.\n\nTo construct CSC from a dense matrix, iterate over columns. For each column, find the indices of non-zero elements, append those values to the values list and the row indices to the row indices list, and record the cumulative count in the column pointer. Using PyTorch, we convert the input to a tensor, use torch.nonzero to efficiently gather non-zero positions per column, and index-select to collect corresponding values. This ensures correct column-major ordering and linear-time processing with respect to the number of elements.\n\nThis approach naturally handles empty columns: if a column has no non-zero entries, the column pointer repeats the previous cumulative count, indicating zero elements for that column. The output lists are standard Python lists for easy interoperability.",
  "solutionCode": "import torch\nfrom typing import List, Tuple\n\n\ndef compressed_col_sparse_matrix(dense_matrix: List[List[float]]) -> Tuple[List[float], List[int], List[int]]:\n    \"\"\"\n    Convert a dense matrix (list of lists) into Compressed Column Sparse (CSC) representation.\n\n    Args:\n        dense_matrix: 2D list representing the dense matrix of shape (m, n).\n\n    Returns:\n        A tuple (values, row_indices, col_ptr):\n          - values: list of non-zero values in column-major order\n          - row_indices: list of row indices corresponding to each value\n          - col_ptr: list of length n+1 where col_ptr[j] is the starting index in `values`\n                      for column j, and col_ptr[n] == len(values)\n    \"\"\"\n    # Convert input to a 2D torch tensor\n    t = torch.tensor(dense_matrix)\n    if t.dim() != 2:\n        raise ValueError(\"dense_matrix must be a 2D list representing a matrix\")\n\n    m, n = t.shape\n\n    values: List[float] = []\n    row_indices: List[int] = []\n    col_ptr: List[int] = [0]\n\n    # Iterate column-wise to ensure column-major order\n    for j in range(n):\n        col = t[:, j]\n        # Find row indices of non-zeros in this column\n        nz_rows = torch.nonzero(col != 0, as_tuple=True)[0]\n        if nz_rows.numel() > 0:\n            col_vals = col.index_select(0, nz_rows)\n            # Extend Python lists\n            values.extend(col_vals.tolist())\n            row_indices.extend(nz_rows.tolist())\n        # Record the cumulative count of non-zeros up to the end of this column\n        col_ptr.append(len(values))\n\n    return values, row_indices, col_ptr\n\n\n# Example usage\nif __name__ == \"__main__\":\n    dense_matrix = [\n        [0, 0, 3, 0],\n        [1, 0, 0, 4],\n        [0, 2, 0, 0],\n    ]\n    vals, row_idx, col_ptr = compressed_col_sparse_matrix(dense_matrix)\n    print(vals)      # [1, 2, 3, 4]\n    print(row_idx)   # [1, 2, 0, 1]\n    print(col_ptr)   # [0, 1, 2, 3, 4]\n",
  "timeComplexity": "O(m*n)",
  "spaceComplexity": "O(nnz + n)",
  "platform": "deepml"
};
