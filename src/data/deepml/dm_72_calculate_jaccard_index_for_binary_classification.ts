import { Problem } from '../../types';

export const DM_72_CALCULATE_JACCARD_INDEX_FOR_BINARY_CLASSIFICATION: Problem = {
  "id": "dm_72_calculate_jaccard_index_for_binary_classification",
  "title": "Calculate Jaccard Index for Binary Classification",
  "difficulty": "Easy",
  "tags": [
    "Loss Functions",
    "Matrix Operations"
  ],
  "descriptionMarkdown": "Implement a function jaccard_index(y_true, y_pred) that computes the Jaccard Index (Intersection over Union) for binary classification. The Jaccard Index measures the similarity between two binary sets and is defined as the size of the intersection divided by the size of the union.\n\nDefinition:\n- Jaccard Index = |y_true \u2229 y_pred| / |y_true \u222a y_pred|\n\nRequirements:\n- y_true and y_pred are binary arrays (same length) representing true and predicted labels.\n- Return the Jaccard Index as a float.\n- Handle edge cases:\n  - No overlap between y_true and y_pred.\n  - Both arrays contain only zeros (define the index as 1.0, since both sets are empty and perfectly match).\n\nExample:\n- Input:\n  - y_true = [1, 0, 1, 1, 0, 1]\n  - y_pred = [1, 0, 1, 0, 0, 1]\n- Output: 0.75 (3 intersections out of 4 in the union)",
  "solutionExplanation": "The Jaccard Index for binary classification is computed as the ratio between the number of positions where both y_true and y_pred are 1 (the intersection) and the number of positions where at least one of them is 1 (the union). In terms of confusion matrix components for the positive class, this is TP / (TP + FP + FN).\n\nTo implement this efficiently in PyTorch, we first convert the inputs to boolean tensors where nonzero values are treated as True. We then use element-wise logical operators to compute the intersection (logical AND) and union (logical OR), and count the number of True values in each. If the union is zero (both inputs are all zeros), we return 1.0 to indicate perfect agreement on the empty set. Otherwise, we return the ratio intersection/union, rounded to three decimal places.",
  "solutionCode": "import torch\n\ndef jaccard_index(y_true, y_pred):\n    \"\"\"\n    Compute the Jaccard Index (Intersection over Union) for binary classification.\n\n    Args:\n        y_true: Iterable, list, numpy array, or torch tensor of binary labels.\n        y_pred: Iterable, list, numpy array, or torch tensor of binary predictions.\n\n    Returns:\n        float: Jaccard Index rounded to 3 decimals.\n    \"\"\"\n    # Convert inputs to torch tensors (on CPU) and flatten\n    t_true = torch.as_tensor(y_true).view(-1)\n    t_pred = torch.as_tensor(y_pred).view(-1)\n\n    if t_true.numel() != t_pred.numel():\n        raise ValueError(\"y_true and y_pred must have the same number of elements\")\n\n    # Convert to boolean tensors: any nonzero value is treated as 1/True\n    b_true = t_true != 0\n    b_pred = t_pred != 0\n\n    # Compute intersection and union using boolean logic\n    intersection = torch.count_nonzero(b_true & b_pred).item()\n    union = torch.count_nonzero(b_true | b_pred).item()\n\n    # Handle edge case: both sets empty -> perfect match\n    if union == 0:\n        return 1.0\n\n    score = intersection / union\n    return round(float(score), 3)\n\n# Example usage\nif __name__ == \"__main__\":\n    y_true = [1, 0, 1, 1, 0, 1]\n    y_pred = [1, 0, 1, 0, 0, 1]\n    print(jaccard_index(y_true, y_pred))  # Expected: 0.75\n\n    # Edge cases\n    print(jaccard_index([0, 0, 0], [0, 0, 0]))  # Expected: 1.0 (both empty)\n    print(jaccard_index([1, 1, 0], [0, 0, 1]))  # Expected: 0.0 (no overlap)\n",
  "timeComplexity": "O(N)",
  "spaceComplexity": "O(1)",
  "platform": "deepml"
};
