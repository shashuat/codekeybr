import { Problem } from '../../types';

export const DM_12_SINGULAR_VALUE_DECOMPOSITION__SVD__OF_2X2_MATRIX: Problem = {
  "id": "dm_12_singular_value_decomposition_svd_of_2x2_matrix",
  "title": "Singular Value Decomposition (SVD) of 2x2 Matrix",
  "difficulty": "Hard",
  "tags": [
    "Linear Algebra",
    "Matrix Operations"
  ],
  "descriptionMarkdown": "Write a Python function that computes an approximate Singular Value Decomposition (SVD) of a real 2x2 matrix using one Jacobi rotation.\n\nInput:\n- A: a NumPy-like array of shape (2, 2)\n\nRules:\n- You may use basic tensor operations (matrix multiplication, transpose, element-wise math, etc.)\n- Do NOT call any high-level SVD routine\n- Use a single Jacobi rotation step (no iterative refinements)\n\nReturn: A tuple (U, S, Vt) where:\n- U is a 2x2 orthogonal matrix (left singular vectors)\n- S is a length-2 array containing the singular values\n- Vt is the transpose of the right singular vector matrix V\n\nThe decomposition should satisfy: A \u2248 U @ diag(S) @ Vt\n\nExample:\n- Input: A = [[2, 1], [1, 2]]\n- Output (approximately):\n  - U \u2248 [[0.707, -0.707], [0.707, 0.707]]\n  - S = [3.0, 1.0]\n  - Vt \u2248 [[0.707, 0.707], [-0.707, 0.707]]",
  "solutionExplanation": "For a 2x2 real matrix A, the right singular vectors are the eigenvectors of the symmetric matrix A^T A, and the singular values are the square roots of its eigenvalues. A single Jacobi rotation exactly diagonalizes any 2x2 symmetric matrix, so one Jacobi step suffices to obtain V and the singular values.\n\nWe first form S = A^T A = [[a, d], [d, b]]. If d = 0, S is already diagonal and the rotation is the identity. Otherwise, we compute a numerically stable Jacobi rotation parameters using tau = (b \u2212 a) / (2d), then t = sign(tau) / (|tau| + sqrt(1 + tau^2)), with c = 1 / sqrt(1 + t^2) and s = t c. The Givens rotation G = [[c, s], [\u2212s, c]] diagonalizes S via G^T S G. The diagonal entries are the eigenvalues; their square roots give the singular values. We then sort the singular values in descending order and permute V accordingly.\n\nFinally, we compute U from U = A V diag(1 / S). If a singular value is (near) zero, we construct the corresponding column of U as the unit vector orthogonal to the other column to maintain orthonormality. This produces orthogonal U and V and nonnegative singular values S such that A \u2248 U diag(S) V^T after a single Jacobi rotation.",
  "solutionCode": "import torch\n\ndef svd_2x2_jacobi(A: torch.Tensor, eps: float = 1e-12):\n    \"\"\"Compute an SVD of a 2x2 real matrix using a single Jacobi rotation.\n\n    Args:\n        A: torch.Tensor of shape (2, 2), real-valued.\n        eps: small tolerance for numerical stability.\n\n    Returns:\n        U: torch.Tensor of shape (2, 2), orthogonal (left singular vectors)\n        S: torch.Tensor of shape (2,), nonnegative singular values (descending)\n        Vt: torch.Tensor of shape (2, 2), transpose of right singular vectors\n    \"\"\"\n    if not isinstance(A, torch.Tensor):\n        raise TypeError(\"A must be a torch.Tensor\")\n    if A.shape != (2, 2):\n        raise ValueError(\"A must have shape (2, 2)\")\n\n    device = A.device\n    dtype = A.dtype\n\n    # Form the symmetric matrix S = A^T A\n    S = A.T @ A\n    a = S[0, 0]\n    b = S[1, 1]\n    d = S[0, 1]\n\n    # Compute one Jacobi rotation G that diagonalizes S\n    if torch.abs(d) <= eps:\n        c = torch.tensor(1.0, dtype=dtype, device=device)\n        s = torch.tensor(0.0, dtype=dtype, device=device)\n    else:\n        tau = (b - a) / (2.0 * d)\n        t = torch.sign(tau) / (torch.abs(tau) + torch.sqrt(1.0 + tau * tau))\n        c = 1.0 / torch.sqrt(1.0 + t * t)\n        s = t * c\n\n    G = torch.stack([\n        torch.stack([c, s]),\n        torch.stack([-s, c])\n    ])\n\n    # Diagonalize S to obtain eigenvalues, then singular values\n    D = G.T @ S @ G\n    lambdas = torch.diag(D)\n    # Clamp in case of tiny negative due to numerical error\n    lambdas = torch.clamp(lambdas, min=0.0)\n    sing_vals = torch.sqrt(lambdas)\n\n    # Sort singular values descending and permute columns of V accordingly\n    idx = torch.argsort(sing_vals, descending=True)\n    Svec = sing_vals[idx]\n    V = G[:, idx]\n\n    # Compute U = A V diag(1/S). Handle zero singular values robustly.\n    AV = A @ V\n    U = torch.zeros_like(A)\n    for i in range(2):\n        si = Svec[i]\n        if si > eps:\n            U[:, i] = AV[:, i] / si\n        else:\n            # Create a perpendicular unit vector to the other column\n            j = 1 - i\n            if Svec[j] > eps:\n                u0 = AV[:, j] / Svec[j]\n                # Perpendicular in R^2\n                perp = torch.stack([-u0[1], u0[0]])\n                # Normalize to unit length (should already be 1, but be safe)\n                U[:, i] = perp / torch.norm(perp)\n            else:\n                # Rank-deficient A with both singular values ~0; choose identity\n                U = torch.eye(2, dtype=dtype, device=device)\n                break\n\n    # Ensure columns of U are unit length (minor numerical guard)\n    for i in range(2):\n        ni = torch.norm(U[:, i])\n        if ni > eps:\n            U[:, i] = U[:, i] / ni\n\n    Vt = V.T\n    return U, Svec, Vt\n\n\nif __name__ == \"__main__\":\n    # Example usage\n    A = torch.tensor([[2.0, 1.0], [1.0, 2.0]])\n    U, S, Vt = svd_2x2_jacobi(A)\n    print(\"U:\\n\", U)\n    print(\"S:\\n\", S)\n    print(\"Vt:\\n\", Vt)\n\n    # Reconstruction check\n    A_recon = U @ torch.diag(S) @ Vt\n    print(\"Reconstructed A:\\n\", A_recon)\n    print(\"Reconstruction error:\", torch.norm(A - A_recon).item())\n",
  "timeComplexity": "O(1)",
  "spaceComplexity": "O(1)",
  "platform": "deepml"
};
