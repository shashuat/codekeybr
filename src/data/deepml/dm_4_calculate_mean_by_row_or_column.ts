import { Problem } from '../../types';

export const DM_4_CALCULATE_MEAN_BY_ROW_OR_COLUMN: Problem = {
  "id": "dm_4_calculate_mean_by_row_or_column",
  "title": "Calculate Mean by Row or Column",
  "difficulty": "Easy",
  "tags": [
    "Linear Algebra",
    "Matrix Operations"
  ],
  "descriptionMarkdown": "Write a Python function that calculates the mean of a matrix either by row or by column, based on a given mode. The function should take a matrix (list of lists) and a mode ('row' or 'column') as input and return a list of means according to the specified mode.\n\nExample:\n- Input: matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]], mode = 'column'\n- Output: [4.0, 5.0, 6.0]\n- Reasoning: Column-wise means are [(1+4+7)/3, (2+5+8)/3, (3+6+9)/3].",
  "solutionExplanation": "To compute the mean by rows or columns efficiently, we can leverage PyTorch tensors and their vectorized operations. First, we validate that the input is a non-empty, rectangular list of lists. Then, we convert the matrix to a float32 torch.Tensor. Using torch.mean along a chosen dimension yields the desired means in a single, efficient step.\n\nSpecifically, when mode is 'row', we compute the mean along dimension 1 (across columns) to get a mean for each row. When mode is 'column', we compute the mean along dimension 0 (down the rows) to get a mean for each column. We return the result as a standard Python list for compatibility with the problem's expected output format. Robust error handling is included for invalid modes, empty inputs, and non-rectangular matrices.",
  "solutionCode": "import torch\nimport torch.nn as nn\nfrom typing import List\n\ndef calculate_matrix_mean(matrix: List[List[float]], mode: str) -> List[float]:\n    \"\"\"\n    Calculate the mean of a matrix either by row or by column using PyTorch.\n\n    Args:\n        matrix: A non-empty rectangular list of lists (rows) of numeric values.\n        mode: 'row' to compute mean for each row, 'column' for each column.\n\n    Returns:\n        A list of floats representing the means according to the specified mode.\n\n    Raises:\n        ValueError: If the mode is invalid, matrix is empty/non-rectangular, or contains non-numeric values.\n    \"\"\"\n    if mode not in (\"row\", \"column\"):\n        raise ValueError(\"mode must be 'row' or 'column'\")\n\n    if not isinstance(matrix, list) or len(matrix) == 0:\n        raise ValueError(\"matrix must be a non-empty list of lists\")\n\n    # Validate rectangular shape and non-empty rows\n    if any(not isinstance(row, list) or len(row) == 0 for row in matrix):\n        raise ValueError(\"matrix must contain non-empty lists (rows)\")\n    row_lengths = [len(row) for row in matrix]\n    if any(l != row_lengths[0] for l in row_lengths):\n        raise ValueError(\"matrix must be rectangular (all rows must have the same length)\")\n\n    # Convert to torch tensor (float32). This will raise if entries are not numeric\n    try:\n        t = torch.tensor(matrix, dtype=torch.float32)\n    except Exception as e:\n        raise ValueError(f\"matrix contains non-numeric values: {e}\")\n\n    dim = 1 if mode == 'row' else 0\n    means = t.mean(dim=dim)\n    return means.tolist()\n\n\ndef solution():\n    # Example usage\n    example_matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n    col_means = calculate_matrix_mean(example_matrix, 'column')  # [4.0, 5.0, 6.0]\n    row_means = calculate_matrix_mean(example_matrix, 'row')     # [2.0, 5.0, 8.0]\n    return {\"column\": col_means, \"row\": row_means}\n\nif __name__ == \"__main__\":\n    print(solution())\n",
  "timeComplexity": "O(R*C)",
  "spaceComplexity": "O(R*C)",
  "platform": "deepml"
};
