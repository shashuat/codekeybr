import { Problem } from '../../types';

export const DM_11_SOLVE_LINEAR_EQUATIONS_USING_JACOBI_METHOD: Problem = {
  "id": "dm_11_solve_linear_equations_using_jacobi_method",
  "title": "Solve Linear Equations using Jacobi Method",
  "difficulty": "Medium",
  "tags": [
    "Linear Algebra",
    "Matrix Operations"
  ],
  "descriptionMarkdown": "Write a Python function that uses the Jacobi method to solve a system of linear equations given by Ax = b. The function should iterate n times, rounding each intermediate solution to four decimal places, and return the approximate solution x.\n\nExample:\n- Input: A = [[5, -2, 3], [-3, 9, 1], [2, -1, -7]], b = [-1, 2, 3], n = 2\n- Output: [0.146, 0.2032, -0.5175]\n\nThe Jacobi method iteratively solves each equation for x[i] using the formula:\n\nx[i] = (1 / a_ii) * (b[i] - sum(a_ij * x[j] for j != i))\n\nwhere a_ii is the diagonal element of A and a_ij are the off-diagonal elements.",
  "solutionExplanation": "The Jacobi method is an iterative algorithm for solving the linear system Ax = b by decomposing A into its diagonal and off-diagonal parts. For each iteration, the next estimate x^(k+1) is computed solely from the previous estimate x^(k), ensuring updates are decoupled across variables. Specifically, if D is the diagonal of A and R = A \u2212 D, then the iteration is x^(k+1) = D^{-1} (b \u2212 R x^(k)). Starting from an initial guess (commonly the zero vector), this process is repeated for a fixed number of iterations or until convergence.\n\nIn this task, we perform exactly n iterations and, after each iteration, we round the intermediate solution to four decimal places before using it in the next step. This matches the example behavior and ensures deterministic rounding effects at each iteration. While Jacobi typically requires conditions like diagonal dominance for convergence, here we only need to implement the fixed-iteration procedure. The PyTorch implementation leverages efficient tensor operations and avoids Python loops over indices.",
  "solutionCode": "import torch\nimport torch.nn as nn\nfrom typing import Union, List, Sequence\n\ndef solve_jacobi(A: Union[torch.Tensor, Sequence[Sequence[float]]],\n                 b: Union[torch.Tensor, Sequence[float]],\n                 n: int) -> List[float]:\n    \"\"\"\n    Solve Ax = b using the Jacobi iterative method for n iterations.\n\n    Each intermediate solution vector is rounded to 4 decimal places\n    before being used in the next iteration.\n\n    Args:\n        A: Square coefficient matrix (NxN), list of lists or torch.Tensor.\n        b: Right-hand side vector (N), list or torch.Tensor.\n        n: Number of Jacobi iterations to perform (non-negative integer).\n\n    Returns:\n        List[float]: Approximate solution vector after n iterations.\n    \"\"\"\n    # Convert inputs to double-precision tensors for stable rounding\n    A_t = torch.as_tensor(A, dtype=torch.float64)\n    b_t = torch.as_tensor(b, dtype=torch.float64).flatten()\n\n    # Basic validations\n    if A_t.ndim != 2 or A_t.shape[0] != A_t.shape[1]:\n        raise ValueError(\"A must be a square 2D matrix.\")\n    if b_t.ndim != 1 or b_t.shape[0] != A_t.shape[0]:\n        raise ValueError(\"b must be a 1D vector with length equal to A's dimension.\")\n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer.\")\n\n    N = A_t.shape[0]\n    D = torch.diag(A_t)  # diagonal entries (size N)\n    if torch.any(D == 0):\n        raise ValueError(\"Matrix A has zero(s) on its diagonal; Jacobi division by zero.\")\n\n    # R = A with zeroed diagonal\n    R = A_t.clone()\n    R.fill_diagonal_(0.0)\n\n    # Initial guess x^(0) = 0\n    x = torch.zeros(N, dtype=torch.float64)\n\n    # Scale used for rounding to 4 decimal places\n    scale = 1e4\n\n    # Perform n iterations\n    for _ in range(int(n)):\n        # Efficient matrix-vector product for off-diagonal part\n        Rx = R.mv(x)  # (N,)\n        x = (b_t - Rx) / D\n        # Round to 4 decimal places before next iteration\n        x = torch.round(x * scale) / scale\n\n    return x.tolist()\n\n# Example usage\nif __name__ == \"__main__\":\n    A = [[5, -2, 3],\n         [-3, 9, 1],\n         [2, -1, -7]]\n    b = [-1, 2, 3]\n    n = 2\n    approx = solve_jacobi(A, b, n)\n    print(approx)  # Expected: [0.146, 0.2032, -0.5175]\n\n\ndef solution():\n    # Provided wrapper to comply with expected interface, returns the example result\n    A = [[5, -2, 3],\n         [-3, 9, 1],\n         [2, -1, -7]]\n    b = [-1, 2, 3]\n    n = 2\n    return solve_jacobi(A, b, n)\n",
  "timeComplexity": "O(n_iter * N^2)",
  "spaceComplexity": "O(N^2)",
  "platform": "deepml"
};
