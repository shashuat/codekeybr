import { Problem } from '../../types';

export const DM_73_CALCULATE_DICE_SCORE_FOR_CLASSIFICATION: Problem = {
  "id": "dm_73_calculate_dice_score_for_classification",
  "title": "Calculate Dice Score for Classification",
  "difficulty": "Easy",
  "tags": [
    "Loss Functions",
    "Probability"
  ],
  "descriptionMarkdown": "Task: Compute the Dice Score\n\nImplement a function dice_score(y_true, y_pred) that calculates the Dice Score (S\u00f8rensen\u2013Dice coefficient, equivalent to the F1-score for binary labels) for binary classification. The inputs are two binary arrays (or tensors) of the same length representing true and predicted labels.\n\nRequirements:\n- Compute Dice Score between y_true and y_pred.\n- Return the score as a float rounded to 3 decimal places.\n- Handle edge cases, such as when there are no true or predicted positives.\n\nDefinition:\n- Dice Score = 2 * |y_true \u2229 y_pred| / (|y_true| + |y_pred|)\n- Ranges from 0 (no overlap) to 1 (perfect overlap).\n\nExample:\n- y_true = [1, 1, 0, 1, 0, 1]\n- y_pred = [1, 1, 0, 0, 0, 1]\n- Dice Score = 2 * 3 / (4 + 3) = 0.857",
  "solutionExplanation": "The Dice Score measures the overlap between the set of predicted positives and true positives. For binary vectors, the intersection is the count of positions where both y_true and y_pred are 1. The denominator is the sum of positives in both arrays. The score is computed as 2 * intersection / (sum_true + sum_pred).\n\nEdge cases include when both y_true and y_pred contain no positives. In that case, there is a perfect match of empty sets, so we define the Dice Score as 1.0. If one is empty and the other is not, the intersection is zero while the denominator is positive, giving a score of 0.0. We also ensure inputs are binarized (threshold at 0.5) and flattened to handle various input shapes consistently.\n\nThe implementation uses PyTorch tensor operations for efficient and concise computation, converts any input-like arrays to tensors, performs elementwise operations, and returns a Python float rounded to three decimals.",
  "solutionCode": "import torch\n\ndef dice_score(y_true, y_pred):\n    \"\"\"\n    Compute the Dice Score (S\u00f8rensen\u2013Dice coefficient) for binary classification.\n\n    Args:\n        y_true: Array-like or torch.Tensor of binary labels (0/1).\n        y_pred: Array-like or torch.Tensor of binary predictions (0/1 or logits/probabilities to be thresholded).\n\n    Returns:\n        float: Dice score rounded to 3 decimal places.\n    \"\"\"\n    # Convert inputs to tensors\n    y_true_t = torch.as_tensor(y_true)\n    y_pred_t = torch.as_tensor(y_pred)\n\n    # Validate same number of elements\n    if y_true_t.numel() != y_pred_t.numel():\n        raise ValueError(\"y_true and y_pred must have the same number of elements\")\n\n    # Flatten and convert to float tensors\n    y_true_t = y_true_t.reshape(-1).to(dtype=torch.float32)\n    y_pred_t = y_pred_t.reshape(-1).to(dtype=torch.float32)\n\n    # Binarize in case inputs are probabilities/logits\n    y_true_t = (y_true_t > 0.5).to(torch.float32)\n    y_pred_t = (y_pred_t > 0.5).to(torch.float32)\n\n    # Compute intersection and sums\n    intersection = torch.sum(y_true_t * y_pred_t)\n    sum_true = torch.sum(y_true_t)\n    sum_pred = torch.sum(y_pred_t)\n    denom = sum_true + sum_pred\n\n    # Handle edge case: no positives in both => perfect match of empty sets\n    if denom.item() == 0.0:\n        dice = torch.tensor(1.0)\n    else:\n        dice = (2.0 * intersection) / denom\n\n    return round(float(dice.item()), 3)\n\n\ndef solution():\n    # Example usage\n    y_true = torch.tensor([1, 1, 0, 1, 0, 1])\n    y_pred = torch.tensor([1, 1, 0, 0, 0, 1])\n    score = dice_score(y_true, y_pred)\n    print(score)  # Expected: 0.857\n    return score\n",
  "timeComplexity": "O(N)",
  "spaceComplexity": "O(1)",
  "platform": "deepml"
};
