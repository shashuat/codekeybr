import { Problem } from '../../types';

export const DM_138_FIND_THE_BEST_GINI_BASED_SPLIT_FOR_A_BINARY_DECISION_TREE: Problem = {
  "id": "dm_138_find_the_best_gini_based_split_for_a_binary_decision_tree",
  "title": "Find the Best Gini-Based Split for a Binary Decision Tree",
  "difficulty": "Medium",
  "tags": [
    "Probability",
    "Loss Functions",
    "Matrix Operations"
  ],
  "descriptionMarkdown": "Implement a function that scans every feature and threshold in a small data set, then returns the split that minimises the weighted Gini impurity. Your implementation should support binary class labels (0 or 1) and handle ties gracefully.\n\nYou will write one function:\n\nfind_best_split(X: np.ndarray, y: np.ndarray) -> tuple[int, float]\n\n- X is an n\u00d7d NumPy array of numeric features.\n- y is a length-n NumPy array of 0/1 labels.\n- The function returns (best_feature_index, best_threshold) for the split with the lowest weighted Gini impurity.\n- If several splits share the same impurity, return the first that you encounter while scanning features and thresholds.\n\nExample:\n\nInput:\n\nimport numpy as np\nX = np.array([[2.5],[3.5],[1.0],[4.0]])\ny = np.array([0,1,0,1])\nprint(find_best_split(X, y))\n\nOutput:\n\n(0, 2.5)\n\nReasoning:\n\nSplitting on feature 0 at threshold 2.5 yields two perfectly pure leaves, producing the minimum possible weighted Gini impurity.",
  "solutionExplanation": "We need to evaluate all candidate splits of the form \"feature j <= threshold\" across every feature. For a given feature, consider using each observed value in that feature as a threshold. The split partitions samples into left (x_j <= threshold) and right (x_j > threshold). For each side, compute its Gini impurity: Gini(S) = 1 - sum_k p_k^2, which for binary labels reduces to 2 p (1 - p), where p is the fraction of class-1 samples in S. The quality of a split is the weighted sum of the left/right impurities by their sizes.\n\nAn efficient approach per feature is to sort samples by that feature, then use prefix sums of the labels to compute, in O(1) per candidate, the number of positives on the left and right for each threshold. We only need to evaluate thresholds at the last index of each block of identical feature values, since with the \"<= threshold\" rule all samples with that value must go to the left. We take the minimum weighted impurity across all candidates and features. To handle ties, we scan features in order and, within a feature, thresholds in ascending order; we update the best split only on strictly lower impurity, so the first encountered minimum is returned.",
  "solutionCode": "import torch\nimport torch.nn as nn\nfrom typing import Tuple\nimport numpy as np\n\ndef find_best_split(X: np.ndarray, y: np.ndarray) -> Tuple[int, float]:\n    \"\"\"Return the (feature_index, threshold) that minimises weighted Gini impurity.\n    This implementation uses PyTorch tensors for efficient vectorised computation.\n\n    Args:\n        X: (n, d) NumPy array of features.\n        y: (n,) NumPy array of binary labels {0, 1}.\n\n    Returns:\n        A tuple (best_feature_index, best_threshold).\n        If multiple splits have the same impurity, returns the first encountered\n        when scanning features in index order and thresholds in ascending order.\n    \"\"\"\n    if X.ndim != 2:\n        raise ValueError(\"X must be a 2D array of shape (n, d)\")\n    if y.ndim != 1 or y.shape[0] != X.shape[0]:\n        raise ValueError(\"y must be a 1D array with length equal to number of rows in X\")\n\n    # Convert to torch tensors\n    X_t = torch.as_tensor(X, dtype=torch.float32)\n    y_t = torch.as_tensor(y, dtype=torch.int64)\n\n    n, d = X_t.shape\n    if n == 0:\n        raise ValueError(\"Empty dataset\")\n\n    # Optional: check binary labels\n    unique_y = torch.unique(y_t)\n    if not torch.all((unique_y == 0) | (unique_y == 1)):\n        raise ValueError(\"Labels must be binary (0/1)\")\n\n    total_pos = y_t.sum().to(torch.float32)\n    n_float = float(n)\n\n    best_impurity = float(\"inf\")\n    best_feature = -1\n    best_threshold = 0.0\n\n    for j in range(d):\n        col = X_t[:, j]\n        # Sort feature values and align labels\n        sorted_vals, perm = torch.sort(col)  # ascending\n        sorted_y = y_t[perm]\n\n        # Prefix sums for positives on the left\n        cumsum_pos = sorted_y.cumsum(dim=0).to(torch.float32)\n        left_size = torch.arange(1, n + 1, dtype=torch.float32)\n        left_pos = cumsum_pos\n        right_size = n_float - left_size\n        right_pos = total_pos - left_pos\n\n        # Compute Gini for left and right with safe handling of empty nodes\n        # Gini(p) = 2 p (1 - p) for binary labels\n        gini_left = torch.zeros_like(left_size)\n        mask_left = left_size > 0\n        p_left = torch.zeros_like(left_size)\n        p_left[mask_left] = left_pos[mask_left] / left_size[mask_left]\n        gini_left[mask_left] = 2.0 * p_left[mask_left] * (1.0 - p_left[mask_left])\n\n        gini_right = torch.zeros_like(right_size)\n        mask_right = right_size > 0\n        p_right = torch.zeros_like(right_size)\n        p_right[mask_right] = right_pos[mask_right] / right_size[mask_right]\n        gini_right[mask_right] = 2.0 * p_right[mask_right] * (1.0 - p_right[mask_right])\n\n        weighted_impurity = (left_size * gini_left + right_size * gini_right) / n_float\n\n        # Only consider thresholds at the last occurrence of each unique value\n        # (with \"<= threshold\", all equal values must go to the left)\n        last_mask = torch.ones(n, dtype=torch.bool)\n        if n > 1:\n            last_mask[:-1] = sorted_vals[:-1] != sorted_vals[1:]\n\n        cand_impurities = weighted_impurity[last_mask]\n        if cand_impurities.numel() == 0:\n            continue\n\n        # Find the best candidate for this feature; argmin returns the first min\n        min_val, min_idx = torch.min(cand_impurities, dim=0)\n        if float(min_val.item()) < best_impurity:\n            best_impurity = float(min_val.item())\n            cand_thresholds = sorted_vals[last_mask]\n            best_threshold = float(cand_thresholds[min_idx].item())\n            best_feature = j\n\n    if best_feature < 0:\n        # Fallback: if something went wrong, return the first feature and its min value\n        best_feature = 0\n        best_threshold = float(X_t[:, 0].min().item())\n\n    return best_feature, best_threshold\n\nif __name__ == \"__main__\":\n    # Example usage\n    import numpy as np\n    X = np.array([[2.5], [3.5], [1.0], [4.0]], dtype=float)\n    y = np.array([0, 1, 0, 1], dtype=int)\n    print(find_best_split(X, y))  # Expected: (0, 2.5)\n",
  "timeComplexity": "O(d n log n) due to sorting each feature once and scanning linearly with prefix sums",
  "spaceComplexity": "O(n) additional space for sorted indices and prefix sums per feature",
  "platform": "deepml"
};
