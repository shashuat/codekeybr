import { Problem } from '../../types';

export const DM_71_CALCULATE_ROOT_MEAN_SQUARE_ERROR__RMSE_: Problem = {
  "id": "dm_71_calculate_root_mean_square_error_rmse",
  "title": "Calculate Root Mean Square Error (RMSE)",
  "difficulty": "Easy",
  "tags": [
    "Loss Functions",
    "Matrix Operations"
  ],
  "descriptionMarkdown": "Task: Compute Root Mean Square Error (RMSE)\n\nImplement a function `rmse(y_true, y_pred)` that calculates the Root Mean Square Error (RMSE) between the actual values and the predicted values. RMSE is a standard metric for evaluating regression models, reflecting the typical magnitude of prediction errors (residuals).\n\nRequirements:\n- Compute the RMSE between `y_true` and `y_pred`.\n- Return the RMSE value rounded to three decimal places.\n- Handle edge cases:\n  - Mismatched array shapes.\n  - Empty arrays.\n  - Invalid input types.\n\nDefinition:\nRMSE = sqrt(mean((y_true - y_pred)^2))\n\nExample:\n- Input:\n  - `y_true = [3, -0.5, 2, 7]`\n  - `y_pred = [2.5, 0.0, 2, 8]`\n- Output: `0.612`\n- Reasoning: RMSE = sqrt((0.5^2 + 0.5^2 + 0^2 + 1^2) / 4) = 0.612",
  "solutionExplanation": "The Root Mean Square Error (RMSE) is defined as the square root of the average of squared differences between actual and predicted values. It penalizes larger errors more than smaller ones due to the squaring operation and is expressed in the same units as the target variable, making it easy to interpret.\n\nTo compute RMSE robustly, we first validate the inputs: ensure both are array-like numeric data, non-empty, and have matching shapes. We then convert them to PyTorch tensors of floating type, check for NaN or Inf values, compute the squared differences element-wise, average them to get the mean squared error (MSE), and finally take the square root to obtain the RMSE. The result is returned rounded to three decimal places, as required.",
  "solutionCode": "import torch\nimport torch.nn as nn\n\ndef rmse(y_true, y_pred):\n    \"\"\"\n    Compute Root Mean Square Error (RMSE) between y_true and y_pred.\n\n    Parameters:\n        y_true: array-like (list/tuple/torch.Tensor/np.ndarray)\n        y_pred: array-like (list/tuple/torch.Tensor/np.ndarray)\n\n    Returns:\n        float: RMSE rounded to three decimal places.\n\n    Raises:\n        TypeError: If inputs are not array-like numeric types.\n        ValueError: If inputs are empty, contain non-finite values, or have mismatched shapes.\n    \"\"\"\n    # Convert inputs to tensors\n    try:\n        yt = torch.as_tensor(y_true)\n        yp = torch.as_tensor(y_pred)\n    except Exception as e:\n        raise TypeError(\"y_true and y_pred must be array-like numeric types.\") from e\n\n    # Validate non-empty\n    if yt.numel() == 0 or yp.numel() == 0:\n        raise ValueError(\"Inputs must be non-empty.\")\n\n    # Validate matching shapes\n    if yt.shape != yp.shape:\n        raise ValueError(f\"Shape mismatch: y_true.shape={yt.shape}, y_pred.shape={yp.shape}\")\n\n    # Ensure floating dtype for numerical stability\n    if not torch.is_floating_point(yt):\n        yt = yt.to(torch.float32)\n    if not torch.is_floating_point(yp):\n        yp = yp.to(torch.float32)\n\n    # Validate finiteness\n    if not torch.isfinite(yt).all() or not torch.isfinite(yp).all():\n        raise ValueError(\"Inputs must not contain NaN or Inf values.\")\n\n    # Compute RMSE: sqrt(mean((y_true - y_pred)^2))\n    diff = yt - yp\n    mse = torch.mean(diff.pow(2))\n    rmse_val = torch.sqrt(mse)\n\n    return round(rmse_val.item(), 3)\n\n\ndef solution():\n    # Example usage\n    y_true = [3, -0.5, 2, 7]\n    y_pred = [2.5, 0.0, 2, 8]\n    val = rmse(y_true, y_pred)\n    print(val)  # Expected: 0.612\n    return val\n",
  "timeComplexity": "O(N)",
  "spaceComplexity": "O(1)",
  "platform": "deepml"
};
