import { Problem } from '../../types';

export const DM_18_IMPLEMENT_K_FOLD_CROSS_VALIDATION: Problem = {
  "id": "dm_18_implement_k_fold_cross_validation",
  "title": "Implement K-Fold Cross-Validation",
  "difficulty": "Medium",
  "tags": [
    "Probability"
  ],
  "descriptionMarkdown": "Implement a function to generate train and test splits for K-Fold Cross-Validation. Your task is to divide the dataset into k folds and return a list of train-test indices for each fold.\n\nExample:\n\nInput:\n\n```python\nk_fold_cross_validation(\n    torch.tensor([0,1,2,3,4,5,6,7,8,9]),\n    torch.tensor([0,1,2,3,4,5,6,7,8,9]),\n    k=5,\n    shuffle=False\n)\n```\n\nOutput:\n\n```python\n[([2, 3, 4, 5, 6, 7, 8, 9], [0, 1]),\n ([0, 1, 4, 5, 6, 7, 8, 9], [2, 3]),\n ([0, 1, 2, 3, 6, 7, 8, 9], [4, 5]),\n ([0, 1, 2, 3, 4, 5, 8, 9], [6, 7]),\n ([0, 1, 2, 3, 4, 5, 6, 7], [8, 9])]\n```\n\nReasoning:\nThe function splits the dataset into 5 folds without shuffling and returns train-test splits for each iteration.",
  "solutionExplanation": "K-Fold Cross-Validation partitions the dataset indices into k contiguous folds (unless shuffling is requested), then iterates through the folds using each as a test set once while the remaining k\u22121 folds form the training set. If the number of samples is not divisible by k, the first remainder folds receive one extra sample so that all samples are covered and folds differ in size by at most one.\n\nWe first create a tensor of indices [0, 1, ..., N\u22121]. If shuffle is True, we randomly permute these indices using torch.randperm (optionally with a provided torch.Generator for reproducibility). We then compute fold boundaries using the base size N // k and distribute the remainder N % k across the first folds. For each fold, we slice out the test indices and concatenate the remaining indices to form the training indices. Finally, we convert indices to Python lists for compatibility with the expected output format.",
  "solutionCode": "import torch\nimport torch.nn as nn\nfrom typing import List, Tuple, Optional\n\ndef k_fold_cross_validation(\n    X: torch.Tensor,\n    y: torch.Tensor,\n    k: int = 5,\n    shuffle: bool = True,\n    generator: Optional[torch.Generator] = None,\n) -> List[Tuple[List[int], List[int]]]:\n    \"\"\"\n    Generate train/test index splits for K-Fold Cross-Validation using PyTorch.\n\n    Args:\n        X: Input features tensor of shape (N, ...).\n        y: Target tensor of shape (N, ...). Only the first dimension (N) is used to validate alignment.\n        k: Number of folds (k >= 2 and k <= N).\n        shuffle: Whether to shuffle indices before splitting into folds.\n        generator: Optional torch.Generator for reproducible shuffling.\n\n    Returns:\n        A list of length k. Each element is a tuple (train_indices, test_indices), where\n        train_indices and test_indices are Python lists of ints.\n    \"\"\"\n    # Validate inputs\n    if X.shape[0] != y.shape[0]:\n        raise ValueError(f\"X and y must have the same number of samples; got {X.shape[0]} and {y.shape[0]}.\")\n\n    n_samples = int(X.shape[0])\n    if k < 2:\n        raise ValueError(f\"k must be at least 2; got k={k}.\")\n    if k > n_samples:\n        raise ValueError(f\"k must be <= number of samples ({n_samples}); got k={k}.\")\n\n    # Build index tensor\n    if shuffle:\n        indices = torch.randperm(n_samples, generator=generator)\n    else:\n        indices = torch.arange(n_samples)\n\n    # Compute fold sizes (distribute the remainder across the first folds)\n    base = n_samples // k\n    rem = n_samples % k\n    fold_sizes = [base + 1 if i < rem else base for i in range(k)]\n\n    # Generate splits\n    splits: List[Tuple[List[int], List[int]]] = []\n    start = 0\n    for i in range(k):\n        end = start + fold_sizes[i]\n        test_idx = indices[start:end]\n        # Concatenate the parts before and after the test indices\n        train_idx = torch.cat((indices[:start], indices[end:]))\n        splits.append((train_idx.tolist(), test_idx.tolist()))\n        start = end\n\n    return splits\n\n\ndef solution():\n    # Example usage replicating the provided example\n    X = torch.tensor([0,1,2,3,4,5,6,7,8,9])\n    y = torch.tensor([0,1,2,3,4,5,6,7,8,9])\n    splits = k_fold_cross_validation(X, y, k=5, shuffle=False)\n    # Print or return the splits\n    print(splits)\n    return splits\n\nif __name__ == \"__main__\":\n    solution()\n",
  "timeComplexity": "O(N)",
  "spaceComplexity": "O(1)",
  "platform": "deepml"
};
