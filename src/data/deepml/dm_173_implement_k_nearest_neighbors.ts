import { Problem } from '../../types';

export const DM_173_IMPLEMENT_K_NEAREST_NEIGHBORS: Problem = {
  "id": "dm_173_implement_k_nearest_neighbors",
  "title": "Implement K-Nearest Neighbors",
  "difficulty": "Medium",
  "tags": [
    "Linear Algebra",
    "Matrix Operations"
  ],
  "descriptionMarkdown": "Given a list of points in n-dimensional space (each point as a tuple) and a query point, implement a function to find the k nearest neighbors to the query point using Euclidean distance.\n\nExample:\n- Input: points = [(1, 2), (3, 4), (1, 1), (5, 6), (2, 3)], query_point = (2, 2), k = 3\n- Output: [(1, 2), (2, 3), (1, 1)]\n\nThe 3 closest points to (2, 2) are (1, 2), (2, 3), and (1, 1).",
  "solutionExplanation": "To find the k nearest neighbors, compute the Euclidean distance from the query point to every point in the dataset and select the k points with the smallest distances. For n-dimensional points x and query q, the Euclidean distance is ||x \u2212 q||_2 = sqrt(sum_i (x_i \u2212 q_i)^2). Since the square root is monotonic, selecting by squared distances or distances yields the same ordering.\n\nWe implement this efficiently using PyTorch tensors. The input list of tuples is converted to a 2D tensor of shape (N, D), and the query point becomes a 1\u00d7D tensor. We then compute all pairwise distances in a vectorized way using torch.cdist (resulting in an N\u00d71 vector of distances). Finally, we use torch.topk with largest=False to select the k smallest distances and return the corresponding points, preserving ascending order by distance. The implementation handles edge cases such as k larger than the number of points and returns an empty list for non-positive k or empty inputs.",
  "solutionCode": "import torch\nimport torch.nn as nn\nfrom typing import List, Tuple\n\ndef k_nearest_neighbors(points: List[Tuple[float, ...]], query_point: Tuple[float, ...], k: int) -> List[Tuple[float, ...]]:\n    \"\"\"\n    Find k nearest neighbors to a query point using Euclidean distance.\n\n    Args:\n        points: List of tuples representing n-D points, e.g., [(x1, ...), (x2, ...), ...].\n        query_point: Tuple representing the n-D query point.\n        k: Number of nearest neighbors to return.\n\n    Returns:\n        List of k nearest neighbor points as tuples, sorted by increasing distance.\n    \"\"\"\n    # Basic edge cases\n    if k <= 0 or len(points) == 0:\n        return []\n\n    # Convert inputs to tensors\n    pts = torch.tensor(points, dtype=torch.float32)\n    q = torch.tensor(query_point, dtype=torch.float32)\n\n    if pts.ndim != 2:\n        raise ValueError(\"'points' must be a list of tuples of equal length (2D array-like).\")\n    if q.numel() != pts.shape[1]:\n        raise ValueError(\"'query_point' dimensionality must match points dimensionality.\")\n\n    # Ensure query has batch dimension (1, D)\n    q = q.unsqueeze(0)\n\n    # Compute Euclidean distances in a vectorized manner: (N, 1) -> (N,)\n    # torch.cdist is numerically stable and handles general n-D points\n    dists = torch.cdist(pts, q).squeeze(1)\n\n    # Select k smallest distances\n    k_eff = int(min(k, pts.shape[0]))\n    values, indices = torch.topk(dists, k_eff, largest=False, sorted=True)\n\n    # Gather neighbors and return as tuples of Python floats\n    neighbors = [tuple(float(x) for x in pts[i].tolist()) for i in indices.tolist()]\n    return neighbors\n\n\ndef solution():\n    # Example usage\n    points = [(1, 2), (3, 4), (1, 1), (5, 6), (2, 3)]\n    query_point = (2, 2)\n    k = 3\n    result = k_nearest_neighbors(points, query_point, k)\n    print(result)  # Expected: [(1, 2), (2, 3), (1, 1)]\n\nif __name__ == \"__main__\":\n    solution()\n",
  "timeComplexity": "O(Nd + N log k)",
  "spaceComplexity": "O(N)",
  "platform": "deepml"
};
