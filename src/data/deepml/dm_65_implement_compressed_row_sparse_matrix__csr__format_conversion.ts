import { Problem } from '../../types';

export const DM_65_IMPLEMENT_COMPRESSED_ROW_SPARSE_MATRIX__CSR__FORMAT_CONVERSION: Problem = {
  "id": "dm_65_implement_compressed_row_sparse_matrix_csr_format_conversion",
  "title": "Implement Compressed Row Sparse Matrix (CSR) Format Conversion",
  "difficulty": "Easy",
  "tags": [
    "Linear Algebra",
    "Matrix Operations"
  ],
  "descriptionMarkdown": "Convert a dense 2D matrix into the Compressed Row Sparse (CSR) format.\n\nImplement a function compressed_row_sparse_matrix(dense_matrix) that takes a 2D Python list representing a dense matrix and returns a tuple of three lists:\n- Values array: Non-zero elements in row-major order.\n- Column indices array: Column index for each non-zero element.\n- Row pointer array: Cumulative count of non-zero elements by row, indicating the start index of each row in the values array.\n\nExample:\n\nInput:\n\ndense_matrix = [\n  [1, 0, 0, 0],\n  [0, 2, 0, 0],\n  [3, 0, 4, 0],\n  [1, 0, 0, 5]\n]\n\nOutput:\n\nValues array: [1, 2, 3, 4, 1, 5]\n\nColumn indices array: [0, 1, 0, 2, 0, 3]\n\nRow pointer array: [0, 1, 2, 4, 6]",
  "solutionExplanation": "The CSR format stores only the non-zero values along with their positions, making it efficient for sparse matrices. It comprises three arrays: values (nnz-long list of non-zero entries in row-major order), column indices (the column index for each value), and the row pointer (length rows+1) which indicates where each row's data starts in the values array.\n\nTo build the CSR from a dense 2D list, we convert it to a PyTorch tensor and create a boolean mask for non-zero entries. Using torch.nonzero gives us the (row, col) coordinates of non-zero elements in row-major order. The values array is obtained via masked indexing. The row pointer is computed by counting non-zeros per row with torch.bincount and then taking a cumulative sum; we prepend 0 to produce the starting offset for the first row.\n\nThis approach uses efficient PyTorch tensor operations, handles edge cases (empty matrices or rows with all zeros), and returns standard Python lists for easy downstream use.",
  "solutionCode": "import torch\nimport torch.nn as nn\nfrom typing import List, Tuple\n\ndef compressed_row_sparse_matrix(dense_matrix: List[List[float]]) -> Tuple[List[float], List[int], List[int]]:\n    \"\"\"\n    Convert a dense 2D Python list into CSR (Compressed Row Storage) format.\n\n    Args:\n        dense_matrix: 2D list (rows x cols) representing a dense matrix.\n\n    Returns:\n        A tuple (values, col_indices, row_ptr):\n          - values: list of non-zero elements in row-major order\n          - col_indices: list of column indices for each non-zero element\n          - row_ptr: list of cumulative counts indicating start of each row (length rows+1)\n    \"\"\"\n    # Validate input is a 2D list-like structure\n    if not isinstance(dense_matrix, (list, tuple)):\n        raise TypeError(\"dense_matrix must be a 2D list or tuple of lists\")\n\n    rows = len(dense_matrix)\n    if rows == 0:\n        # Empty matrix: no values, no column indices, single 0 in row_ptr\n        return [], [], [0]\n\n    # Ensure rectangular shape\n    num_cols = len(dense_matrix[0]) if isinstance(dense_matrix[0], (list, tuple)) else 0\n    for r, row in enumerate(dense_matrix):\n        if not isinstance(row, (list, tuple)):\n            raise TypeError(\"dense_matrix must be a 2D list or tuple of lists\")\n        if len(row) != num_cols:\n            raise ValueError(\"All rows must have the same number of columns\")\n\n    if num_cols == 0:\n        # Matrix with zero columns\n        return [], [], [0] * (rows + 1)\n\n    # Convert to torch tensor\n    t = torch.tensor(dense_matrix)\n\n    # Mask of non-zero elements\n    mask = t != 0\n    # Indices of non-zero entries in row-major order (default behavior)\n    nz_indices = mask.nonzero(as_tuple=False)  # shape: [nnz, 2]\n\n    # Values and column indices\n    values = t[mask].tolist()\n    col_indices = nz_indices[:, 1].tolist() if nz_indices.numel() > 0 else []\n\n    # Row pointer: cumulative count of non-zeros per row\n    if nz_indices.numel() > 0:\n        counts = torch.bincount(nz_indices[:, 0], minlength=rows)\n        row_ptr_tensor = torch.cat([torch.zeros(1, dtype=counts.dtype), counts.cumsum(0)])\n        row_ptr = [int(x) for x in row_ptr_tensor.tolist()]\n    else:\n        row_ptr = [0] * (rows + 1)\n\n    return values, col_indices, row_ptr\n\n\ndef solution():\n    # Example usage\n    dense_matrix = [\n        [1, 0, 0, 0],\n        [0, 2, 0, 0],\n        [3, 0, 4, 0],\n        [1, 0, 0, 5]\n    ]\n\n    vals, col_idx, row_ptr = compressed_row_sparse_matrix(dense_matrix)\n    print(\"Values array:\", vals)\n    print(\"Column indices array:\", col_idx)\n    print(\"Row pointer array:\", row_ptr)\n\n\nif __name__ == \"__main__\":\n    solution()\n",
  "timeComplexity": "O(R*C) where R and C are the number of rows and columns",
  "spaceComplexity": "O(nnz + R) for outputs (values, col_indices, row_ptr); additional transient memory depends on implementation",
  "platform": "deepml"
};
