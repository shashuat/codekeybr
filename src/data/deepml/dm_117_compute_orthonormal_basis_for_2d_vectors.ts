import { Problem } from '../../types';

export const DM_117_COMPUTE_ORTHONORMAL_BASIS_FOR_2D_VECTORS: Problem = {
  "id": "dm_117_compute_orthonormal_basis_for_2d_vectors",
  "title": "Compute Orthonormal Basis for 2D Vectors",
  "difficulty": "Medium",
  "tags": [
    "Linear Algebra",
    "Matrix Operations"
  ],
  "descriptionMarkdown": "Implement a function that computes an orthonormal basis for the subspace spanned by a list of 2D vectors using the Gram\u2013Schmidt process. The function should take a list of 2D vectors and a tolerance value (tol) to determine linear independence, returning a list of orthonormal vectors (unit length and orthogonal to each other) that span the same subspace. This is a fundamental concept in linear algebra with applications in machine learning, such as feature orthogonalization.\n\nExample:\n- Input: `orthonormal_basis([[1, 0], [1, 1]])`\n- Output: `[tensor([1., 0.]), tensor([0., 1.])]`\n\nReasoning: Start with [1, 0], normalize to [1, 0]. For [1, 1], subtract its projection onto [1, 0] (which is [1, 0]), leaving [0, 1]. Check if norm > 1e-10 (it is 1), then normalize to [0, 1]. The result is an orthonormal basis.",
  "solutionExplanation": "We apply the classical Gram\u2013Schmidt process to the list of input 2D vectors. Iterating over the vectors in order, we subtract from the current vector its projections onto all previously accepted basis vectors. Because the basis vectors are maintained in unit-norm form, the projection simplifies to (v \u00b7 b) b for each existing basis vector b. After removing these components, if the remaining vector has norm greater than the given tolerance, we normalize it and append it to the basis.\n\nIn 2D, the resulting orthonormal basis will contain at most two vectors. The tolerance guards against numerical issues and near-linear dependence (e.g., when an input vector lies almost entirely in the span of the existing basis). This yields a set of unit vectors that are mutually orthogonal and span the same subspace as the inputs, ordered consistently with the original list.",
  "solutionCode": "import torch\nfrom typing import List, Union, Iterable\n\n\ndef orthonormal_basis(vectors: Union[Iterable[Iterable[float]], torch.Tensor], tol: float = 1e-10) -> List[torch.Tensor]:\n    \"\"\"\n    Compute an orthonormal basis for the subspace spanned by a list of 2D vectors\n    using the Gram\u2013Schmidt process.\n\n    Args:\n        vectors: Iterable of 2D vectors (e.g., list of [x, y]) or a tensor of shape (N, 2).\n        tol: Tolerance for deciding linear independence (vectors with norm <= tol are discarded).\n\n    Returns:\n        A list of torch.Tensor vectors (each of shape (2,)) forming an orthonormal basis\n        for the span of the input vectors.\n    \"\"\"\n    # Convert input to a tensor of shape (N, 2)\n    if isinstance(vectors, torch.Tensor):\n        V = vectors.to(dtype=torch.float64)\n    else:\n        V = torch.tensor(list(vectors), dtype=torch.float64)\n\n    if V.ndim != 2 or V.size(-1) != 2:\n        raise ValueError(\"Input must be an iterable of 2D vectors or a tensor of shape (N, 2).\")\n\n    basis: List[torch.Tensor] = []\n\n    for i in range(V.size(0)):\n        v = V[i].clone()\n        # Subtract projections onto existing basis vectors\n        for b in basis:\n            # b is unit norm, so projection is (v\u00b7b) * b\n            v = v - torch.dot(v, b) * b\n\n        # Check if the residual has significant norm\n        norm = torch.linalg.vector_norm(v)\n        if norm > tol:\n            basis.append(v / norm)\n\n        # In 2D, at most two orthonormal vectors exist\n        if len(basis) == 2:\n            break\n\n    return basis\n\n\ndef solution(vectors: Union[Iterable[Iterable[float]], torch.Tensor], tol: float = 1e-10) -> List[torch.Tensor]:\n    \"\"\"Wrapper to match required signature for the problem.\"\"\"\n    return orthonormal_basis(vectors, tol)\n\n\nif __name__ == \"__main__\":\n    # Example usage\n    basis = orthonormal_basis([[1, 0], [1, 1]])\n    print(basis)  # [tensor([1., 0.], dtype=torch.float64), tensor([0., 1.], dtype=torch.float64)]\n",
  "timeComplexity": "O(N)",
  "spaceComplexity": "O(1)",
  "platform": "deepml"
};
