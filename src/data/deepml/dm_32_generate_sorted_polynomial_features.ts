import { Problem } from '../../types';

export const DM_32_GENERATE_SORTED_POLYNOMIAL_FEATURES: Problem = {
  "id": "dm_32_generate_sorted_polynomial_features",
  "title": "Generate Sorted Polynomial Features",
  "difficulty": "Medium",
  "tags": [
    "Linear Algebra",
    "Matrix Operations"
  ],
  "descriptionMarkdown": "Write a Python function that takes a 2-D array X and an integer degree, generates all polynomial feature combinations of the columns of X up to the given degree (inclusive), then sorts the resulting features for each sample from lowest to highest value. Return a new 2-D array whose rows correspond to the input samples and whose columns are the ascending-sorted polynomial features.\n\nExample:\n- Input:\n  - X = [[2, 3], [3, 4], [5, 6]]\n  - degree = 2\n- Output:\n  - [[ 1.,  2.,  3.,  4.,  6.,  9.],\n     [ 1.,  3.,  4.,  9., 12., 16.],\n     [ 1.,  5.,  6., 25., 30., 36.]]\n\nReasoning:\nFor degree = 2 with two input features x1 and x2, the polynomial terms per sample are [1, x1, x2, x1^2, x1\u00b7x2, x2^2]. Sorting these terms ascending per sample yields the final output.",
  "solutionExplanation": "To generate polynomial features up to a given degree without duplicates, we use combinations with replacement over feature indices. For each degree k from 0 to the target degree, we select all unordered k-tuples of feature indices and multiply the corresponding columns. Degree 0 contributes the constant term 1. This ensures each monomial (e.g., x1\u00b7x2) is generated once regardless of order.\n\nWe implement this efficiently with PyTorch by indexing and taking products along the feature dimension for each combination. After assembling all monomial terms into a feature matrix, we sort the features for each sample along the feature axis to satisfy the requirement of ascending-sorted polynomial features per row. Internally, computation uses torch tensors for performance and consistency, and we convert to NumPy only at the boundary if needed.",
  "solutionCode": "import torch\nfrom itertools import combinations_with_replacement\nfrom typing import Union\nimport numpy as np\n\n\ndef polynomial_features_torch(X: Union[torch.Tensor, np.ndarray], degree: int) -> torch.Tensor:\n    \"\"\"Generate sorted polynomial features up to a given degree using PyTorch.\n\n    Args:\n        X: (N, F) input, torch.Tensor or np.ndarray.\n        degree: maximum total degree of polynomial features (>= 0).\n\n    Returns:\n        (N, M) torch.Tensor of ascending-sorted polynomial features per sample.\n    \"\"\"\n    if degree < 0:\n        raise ValueError(\"degree must be >= 0\")\n\n    # Convert input to torch tensor (float) if needed\n    if isinstance(X, np.ndarray):\n        xt = torch.from_numpy(X)\n    elif isinstance(X, torch.Tensor):\n        xt = X\n    else:\n        raise TypeError(\"X must be a torch.Tensor or np.ndarray\")\n\n    if xt.dim() != 2:\n        raise ValueError(\"X must be a 2-D array/tensor\")\n\n    xt = xt.to(dtype=torch.float32)\n\n    N, F = xt.shape\n\n    # Collect monomial terms as list of (N,) tensors\n    terms = []\n\n    # Degree 0 term: constant 1\n    terms.append(torch.ones(N, dtype=xt.dtype, device=xt.device))\n\n    # Degrees 1..degree\n    for k in range(1, degree + 1):\n        for combo in combinations_with_replacement(range(F), k):\n            # xt[:, combo] -> (N, k); product across the k columns\n            term = xt[:, combo].prod(dim=1)\n            terms.append(term)\n\n    # Stack into (N, M)\n    features = torch.stack(terms, dim=1)\n\n    # Sort ascending per sample\n    features_sorted, _ = torch.sort(features, dim=1)\n\n    return features_sorted\n\n\ndef polynomial_features(X: np.ndarray, degree: int) -> np.ndarray:\n    \"\"\"NumPy API-compatible wrapper that computes features using PyTorch and returns np.ndarray.\n\n    Args:\n        X: (N, F) NumPy array.\n        degree: maximum polynomial degree.\n\n    Returns:\n        (N, M) NumPy array of ascending-sorted polynomial features per sample.\n    \"\"\"\n    feats = polynomial_features_torch(X, degree)\n    return feats.cpu().numpy()\n\n\nif __name__ == \"__main__\":\n    # Example usage\n    X = np.array([[2, 3],\n                  [3, 4],\n                  [5, 6]], dtype=float)\n    degree = 2\n    output = polynomial_features(X, degree)\n    print(output)\n    # Expected:\n    # [[ 1.  2.  3.  4.  6.  9.]\n    #  [ 1.  3.  4.  9. 12. 16.]\n    #  [ 1.  5.  6. 25. 30. 36.]]\n",
  "timeComplexity": "O(N * M) where M = sum_{k=0..degree} C(F + k - 1, k)",
  "spaceComplexity": "O(N * M)",
  "platform": "deepml"
};
