import { Problem } from '../../types';

export const DM_51_OPTIMAL_STRING_ALIGNMENT_DISTANCE: Problem = {
  "id": "dm_51_optimal_string_alignment_distance",
  "title": "Optimal String Alignment Distance",
  "difficulty": "Medium",
  "tags": [
    "Matrix Operations"
  ],
  "descriptionMarkdown": "In this problem, you need to implement a function that calculates the Optimal String Alignment (OSA) distance between two given strings. The OSA distance represents the minimum number of edits required to transform one string into another. The allowed edit operations are:\n\n- Insert a character\n- Delete a character\n- Substitute a character\n- Transpose two adjacent characters\n\nEach operation has a cost of 1. Your task is to compute the minimum number of edits needed to convert the first string (s1) into the second string (s2).\n\nExample:\n\n- Input:\n  - source = \"butterfly\"\n  - target = \"dragonfly\"\n  - distance = OSA(source, target)\n  - print(distance)\n- Output:\n  - 6\n- Reasoning:\n  - The OSA distance between \"butterfly\" and \"dragonfly\" is 6. The minimum number of edits required to transform the source string into the target string is 6.",
  "solutionExplanation": "We can solve the Optimal String Alignment distance using dynamic programming. Define a matrix dp of size (n+1) x (m+1), where n = len(source) and m = len(target). The entry dp[i][j] stores the minimum edit cost to transform source[:i] into target[:j]. Initialize the first row and column to represent converting from or to the empty string: dp[i][0] = i and dp[0][j] = j.\n\nFor each position (i, j), compute the minimum of three standard edit operations: deletion dp[i-1][j] + 1, insertion dp[i][j-1] + 1, and substitution dp[i-1][j-1] + cost where cost is 0 if the current characters match and 1 otherwise. Additionally, OSA allows a transposition of two adjacent characters: if i > 1, j > 1, source[i-1] == target[j-2], and source[i-2] == target[j-1], then dp[i][j] can also be dp[i-2][j-2] + 1.\n\nThe value dp[n][m] gives the OSA distance. Unlike the full Damerau\u2013Levenshtein distance, OSA restricts transpositions to adjacent characters and does not allow multiple edits on the same substring more than once, which this DP correctly models.",
  "solutionCode": "import torch\n\ndef OSA(source: str, target: str) -> int:\n    \"\"\"\n    Compute the Optimal String Alignment (OSA) distance between two strings.\n\n    The OSA distance allows insertions, deletions, substitutions, and\n    transpositions of adjacent characters, each with unit cost.\n\n    Args:\n        source: The source string (s1).\n        target: The target string (s2).\n\n    Returns:\n        The OSA distance as an integer.\n    \"\"\"\n    n = len(source)\n    m = len(target)\n\n    # If one string is empty, distance is the length of the other\n    if n == 0:\n        return m\n    if m == 0:\n        return n\n\n    # Create DP matrix of shape (n+1) x (m+1)\n    # dp[i, j] = OSA distance between source[:i] and target[:j]\n    dp = torch.empty((n + 1, m + 1), dtype=torch.int64)\n\n    # Initialize base cases: transforming to/from empty strings\n    dp[0, :] = torch.arange(m + 1, dtype=torch.int64)\n    dp[:, 0] = torch.arange(n + 1, dtype=torch.int64)\n\n    # Fill DP table\n    for i in range(1, n + 1):\n        s_i_1 = source[i - 1]\n        for j in range(1, m + 1):\n            t_j_1 = target[j - 1]\n\n            # Cost of substitution\n            cost = 0 if s_i_1 == t_j_1 else 1\n\n            # Standard edit operations\n            deletion = dp[i - 1, j] + 1\n            insertion = dp[i, j - 1] + 1\n            substitution = dp[i - 1, j - 1] + cost\n\n            # Minimum of insertion, deletion, substitution\n            best = torch.minimum(substitution, torch.minimum(deletion, insertion))\n\n            # OSA-specific adjacent transposition\n            if i > 1 and j > 1 and s_i_1 == target[j - 2] and source[i - 2] == t_j_1:\n                best = torch.minimum(best, dp[i - 2, j - 2] + 1)\n\n            dp[i, j] = best\n\n    return int(dp[n, m].item())\n\n\ndef solution():\n    # Example usage\n    source = \"butterfly\"\n    target = \"dragonfly\"\n    distance = OSA(source, target)\n    print(distance)  # Expected: 6\n    return distance\n",
  "timeComplexity": "O(n * m), where n = len(source) and m = len(target)",
  "spaceComplexity": "O(n * m) for the DP matrix",
  "platform": "deepml"
};
