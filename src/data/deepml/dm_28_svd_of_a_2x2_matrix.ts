import { Problem } from '../../types';

export const DM_28_SVD_OF_A_2X2_MATRIX: Problem = {
  "id": "dm_28_svd_of_a_2x2_matrix",
  "title": "SVD of a 2x2 Matrix",
  "difficulty": "Hard",
  "tags": [
    "Linear Algebra",
    "Matrix Operations"
  ],
  "descriptionMarkdown": "Given a 2x2 matrix A, write a Python function to compute its Singular Value Decomposition (SVD) without using built-in SVD routines. The function should return matrices U, s, and V such that:\n\nA = U @ diag(s) @ V\n\nWhere:\n- U is a 2x2 orthogonal matrix (left singular vectors)\n- s is a length-2 vector of non-negative singular values\n- V is a 2x2 matrix (right singular vectors, arranged so the reconstruction matches the formula above)\n\nExample:\n- Input: A = [[-10, 8], [10, -1]]\n- Output: U, s, V such that U @ diag(s) @ V \u2248 A",
  "solutionExplanation": "For a real matrix A, the singular values are the square roots of the eigenvalues of A^T A, and the corresponding eigenvectors form the right singular vectors. Specifically, we first compute the symmetric matrix B = A^T A and perform an eigen-decomposition B = V \u039b V^T. The singular values s are sqrt(diag(\u039b)) (clamped to handle tiny negative numerical artifacts), and the columns of V are the right singular vectors. We sort the singular values in descending order and reorder V accordingly.\n\nThe left singular vectors U can be obtained via u_i = (A v_i) / s_i for each nonzero singular value s_i. If a singular value is zero (rank-deficient case), we complete U with any orthonormal vector perpendicular to the existing one to ensure U is orthogonal. The problem statement requests A = U diag(s) V (without a transpose on V), so we return V_out = V^T from the conventional SVD to match this reconstruction exactly.\n\nThis approach avoids using built-in SVD functions and relies only on symmetric eigen-decomposition, which is stable and efficient for 2x2 matrices. The final U and V are orthonormal, and s is non-negative and sorted in descending order.",
  "solutionCode": "import torch\n\ndef svd_2x2_torch(A: torch.Tensor):\n    \"\"\"\n    Compute the SVD of a 2x2 matrix A without using torch.linalg.svd.\n    Returns U, s, V such that A \u2248 U @ diag(s) @ V.\n\n    Args:\n        A: torch.Tensor of shape (2, 2)\n    Returns:\n        U: torch.Tensor of shape (2, 2), orthonormal columns (left singular vectors)\n        s: torch.Tensor of shape (2,), non-negative singular values (sorted desc)\n        V: torch.Tensor of shape (2, 2), arranged so that A = U @ diag(s) @ V\n           (note: this V equals the transpose of the conventional V in A = U S V^T)\n    \"\"\"\n    if A.shape != (2, 2):\n        raise ValueError(\"Input must be a 2x2 matrix.\")\n\n    # Ensure floating point for numerical ops\n    if not torch.is_floating_point(A):\n        A = A.to(torch.float64)\n    else:\n        A = A.clone()\n\n    dtype = A.dtype\n    device = A.device\n    # Tolerance tailored to dtype\n    eps = 1e-12 if dtype in (torch.float64, torch.float32) else 1e-6\n\n    # 1) Right singular vectors via eigen-decomposition of A^T A\n    B = A.T @ A  # symmetric 2x2\n    evals, V_cols = torch.linalg.eigh(B)  # ascending eigenvalues; columns are eigenvectors\n\n    # Clamp to handle tiny negative numerical values due to round-off\n    evals = torch.clamp(evals, min=0.0)\n    s = torch.sqrt(evals)\n\n    # Sort singular values in descending order and reorder V accordingly\n    idx = torch.argsort(s, descending=True)\n    s = s[idx]\n    V_cols = V_cols[:, idx]  # columns are right singular vectors (conventional V)\n\n    # 2) Left singular vectors via U = A V / s (column-wise)\n    def _norm(x):\n        return torch.linalg.norm(x)\n\n    u0 = None\n    u1 = None\n\n    # First left vector\n    if s[0] > eps:\n        u0 = A @ V_cols[:, 0] / s[0]\n        n0 = _norm(u0)\n        if n0 > eps:\n            u0 = u0 / n0\n        else:\n            u0 = None\n\n    # Second left vector\n    if s[1] > eps:\n        u1 = A @ V_cols[:, 1] / s[1]\n        n1 = _norm(u1)\n        if n1 > eps:\n            u1 = u1 / n1\n        else:\n            u1 = None\n\n    # Handle rank-deficient cases to ensure U is orthonormal\n    if u0 is None and u1 is None:\n        # A is (close to) zero; pick identity\n        u0 = torch.tensor([1.0, 0.0], dtype=dtype, device=device)\n        u1 = torch.tensor([0.0, 1.0], dtype=dtype, device=device)\n    elif u0 is None:\n        # Build a vector perpendicular to u1\n        u0 = torch.stack([-u1[1], u1[0]])\n        n0 = _norm(u0)\n        if n0 > eps:\n            u0 = u0 / n0\n        else:\n            u0 = torch.tensor([1.0, 0.0], dtype=dtype, device=device)\n    elif u1 is None:\n        # Build a vector perpendicular to u0\n        u1 = torch.stack([-u0[1], u0[0]])\n        n1 = _norm(u1)\n        if n1 > eps:\n            u1 = u1 / n1\n        else:\n            u1 = torch.tensor([0.0, 1.0], dtype=dtype, device=device)\n    else:\n        # Improve orthogonality numerically via Gram-Schmidt for robustness\n        u1 = u1 - torch.dot(u0, u1) * u0\n        n1 = _norm(u1)\n        if n1 > eps:\n            u1 = u1 / n1\n        else:\n            u1 = torch.stack([-u0[1], u0[0]])\n\n    U = torch.stack([u0, u1], dim=1)\n\n    # 3) Return V such that A = U diag(s) V (i.e., V is conventional V^T)\n    V_out = V_cols.T\n\n    return U, s, V_out\n\n\ndef solution():\n    # Example usage\n    A = torch.tensor([[-10.0, 8.0], [10.0, -1.0]])\n    U, s, V = svd_2x2_torch(A)\n\n    # Reconstruct A and compute error\n    S = torch.diag(s)\n    A_hat = U @ S @ V\n    err = torch.linalg.norm(A - A_hat).item()\n\n    print(\"A:\\n\", A)\n    print(\"U:\\n\", U)\n    print(\"s:\", s)\n    print(\"V:\\n\", V)\n    print(\"Reconstruction error ||A - U diag(s) V||_F =\", err)\n\n    return U, s, V\n\nif __name__ == \"__main__\":\n    solution()\n",
  "timeComplexity": "O(1)",
  "spaceComplexity": "O(1)",
  "platform": "deepml"
};
