import { Problem } from '../../types';

export const DM_76_CALCULATE_COSINE_SIMILARITY_BETWEEN_VECTORS: Problem = {
  "id": "dm_76_calculate_cosine_similarity_between_vectors",
  "title": "Calculate Cosine Similarity Between Vectors",
  "difficulty": "Easy",
  "tags": [
    "Linear Algebra",
    "Matrix Operations"
  ],
  "descriptionMarkdown": "Task: Implement cosine_similarity(v1, v2) to compute the cosine similarity between two vectors. Cosine similarity measures the cosine of the angle between two vectors and indicates their directional similarity.\n\nInput:\n- v1 and v2: NumPy arrays representing the input vectors.\n\nOutput:\n- A float representing the cosine similarity, rounded to three decimal places.\n\nConstraints:\n- Both input vectors must have the same shape (same number of elements).\n- Input vectors cannot be empty or have zero magnitude.\n\nExample:\n\n```\nimport numpy as np\nv1 = np.array([1, 2, 3])\nv2 = np.array([2, 4, 6])\nprint(cosine_similarity(v1, v2))\n```\n\nReasoning: The cosine similarity between v1 and v2 is 1.0, indicating perfect similarity.",
  "solutionExplanation": "Cosine similarity between two vectors v1 and v2 is defined as (v1 \u00b7 v2) / (||v1|| ||v2||), where \u00b7 denotes the dot product and ||\u00b7|| denotes the Euclidean norm. This value lies in the range [-1, 1], with 1 indicating that the vectors point in the same direction, -1 indicating opposite directions, and 0 indicating orthogonality.\n\nTo implement this robustly, we first validate that both inputs contain the same number of elements and are non-empty. We then convert inputs to PyTorch tensors, flatten them to 1D, and cast to floating-point for numerical stability. We compute the dot product via torch.dot and the norms via torch.linalg.norm. If either norm is zero, we raise an error per the constraints. Finally, we compute the similarity, clamp it to [-1, 1] to handle minor floating-point noise, and return the result rounded to three decimal places.",
  "solutionCode": "import torch\nimport numpy as np\n\ndef cosine_similarity(v1, v2):\n    \"\"\"\n    Compute the cosine similarity between two vectors using PyTorch.\n\n    Parameters\n    ----------\n    v1 : numpy.ndarray or torch.Tensor or sequence\n        First input vector.\n    v2 : numpy.ndarray or torch.Tensor or sequence\n        Second input vector.\n\n    Returns\n    -------\n    float\n        Cosine similarity rounded to three decimal places.\n\n    Raises\n    ------\n    ValueError\n        If inputs have different lengths, are empty, or have zero magnitude.\n    \"\"\"\n    # Convert inputs to torch.Tensor\n    if isinstance(v1, np.ndarray):\n        t1 = torch.from_numpy(v1)\n    elif isinstance(v1, torch.Tensor):\n        t1 = v1\n    else:\n        t1 = torch.tensor(v1)\n\n    if isinstance(v2, np.ndarray):\n        t2 = torch.from_numpy(v2)\n    elif isinstance(v2, torch.Tensor):\n        t2 = v2\n    else:\n        t2 = torch.tensor(v2)\n\n    # Validate same number of elements and non-empty\n    if t1.numel() != t2.numel():\n        raise ValueError(\"Input vectors must have the same number of elements.\")\n    if t1.numel() == 0:\n        raise ValueError(\"Input vectors cannot be empty.\")\n\n    # Flatten to 1D and ensure floating dtype for dot/norm\n    t1 = t1.reshape(-1).to(dtype=torch.float32)\n    t2 = t2.reshape(-1).to(dtype=torch.float32)\n\n    # Compute norms and validate non-zero magnitudes\n    n1 = torch.linalg.norm(t1)\n    n2 = torch.linalg.norm(t2)\n    if n1 == 0 or n2 == 0:\n        raise ValueError(\"Input vectors must have non-zero magnitude.\")\n\n    # Cosine similarity: (v1 \u00b7 v2) / (||v1|| * ||v2||)\n    sim = torch.dot(t1, t2) / (n1 * n2)\n\n    # Clamp to [-1, 1] to counter minor numerical drift\n    sim = torch.clamp(sim, -1.0, 1.0)\n\n    # Return rounded to three decimals\n    return round(sim.item(), 3)\n\n\ndef solution():\n    # Example usage matching the prompt\n    v1 = np.array([1, 2, 3])\n    v2 = np.array([2, 4, 6])\n    result = cosine_similarity(v1, v2)\n    print(result)  # Expected: 1.0\n    return result\n\n\nif __name__ == \"__main__\":\n    solution()\n",
  "timeComplexity": "O(N)",
  "spaceComplexity": "O(1)",
  "platform": "deepml"
};
