import { Problem } from '../../types';

export const DM_10_CALCULATE_COVARIANCE_MATRIX: Problem = {
  "id": "dm_10_calculate_covariance_matrix",
  "title": "Calculate Covariance Matrix",
  "difficulty": "Easy",
  "tags": [
    "Linear Algebra",
    "Matrix Operations",
    "Probability"
  ],
  "descriptionMarkdown": "Write a Python function to calculate the covariance matrix for a given set of vectors. The function should take a list of lists, where each inner list represents a feature with its observations, and return a covariance matrix as a list of lists.\n\nExample:\n- Input: [[1, 2, 3], [4, 5, 6]]\n- Output: [[1.0, 1.0], [1.0, 1.0]]\n\nReasoning: The covariance between the two features is calculated based on their deviations from the mean. For the given vectors, both covariances are 1.0, resulting in a symmetric covariance matrix. Use the unbiased (sample) covariance, i.e., divide by (n - 1), where n is the number of observations.",
  "solutionExplanation": "To compute the covariance matrix for a set of features, stack the features into a matrix X of shape (F, N), where F is the number of features and N is the number of observations per feature. First, center each feature by subtracting its mean across observations. The sample covariance matrix is then given by (X_centered @ X_centered^T) / (N - 1). This yields an F x F symmetric matrix where diagonal entries are sample variances and off-diagonal entries are sample covariances.\n\nUsing PyTorch, we can implement this efficiently with tensor operations. We validate that all features have the same number of observations and require at least two observations to compute an unbiased sample covariance. The function returns a standard Python list of lists for compatibility with the prompt, while leveraging PyTorch for the computation.",
  "solutionCode": "import torch\nimport torch.nn as nn\nfrom typing import List\n\ndef calculate_covariance_matrix(vectors: List[List[float]]) -> List[List[float]]:\n    \"\"\"Compute the unbiased sample covariance matrix for feature vectors.\n\n    Args:\n        vectors: A list of lists with shape (F, N), where each inner list is a feature's\n                 observations across samples (N observations per feature).\n\n    Returns:\n        A list of lists representing the F x F covariance matrix (float values).\n\n    Raises:\n        ValueError: If input is malformed (e.g., inconsistent lengths) or if there are\n                    fewer than two observations per feature.\n    \"\"\"\n    # Handle empty input explicitly\n    if vectors is None or len(vectors) == 0:\n        return []\n\n    n_features = len(vectors)\n    n_obs = len(vectors[0]) if n_features > 0 else 0\n\n    # Validate that all features have the same number of observations\n    for row in vectors:\n        if len(row) != n_obs:\n            raise ValueError(\"All features must have the same number of observations.\")\n\n    if n_obs < 2:\n        raise ValueError(\"At least two observations are required to compute sample covariance.\")\n\n    # Convert to a torch tensor (F x N). Use double precision for numerical stability.\n    X = torch.tensor(vectors, dtype=torch.float64)\n\n    # Center features by subtracting the mean per feature (along observations axis)\n    X_centered = X - X.mean(dim=1, keepdim=True)\n\n    # Unbiased sample covariance: divide by (N - 1)\n    cov = (X_centered @ X_centered.t()) / (n_obs - 1)\n\n    # Return as a standard Python list of lists\n    return cov.tolist()\n\n\ndef solution():\n    # Example usage and basic tests\n    ex = [[1, 2, 3], [4, 5, 6]]\n    out = calculate_covariance_matrix(ex)\n    print(\"Covariance matrix for [[1,2,3],[4,5,6]]:\", out)\n    assert all(abs(out[i][j] - 1.0) < 1e-9 for i in range(2) for j in range(2))\n\n    # Single feature: sample variance of [1,2,3,4] is 1.6666666667\n    out2 = calculate_covariance_matrix([[1, 2, 3, 4]])\n    assert abs(out2[0][0] - 1.6666666666666667) < 1e-9\n\n    # Two identical zero features -> zero covariance matrix\n    out3 = calculate_covariance_matrix([[0, 0, 0], [0, 0, 0]])\n    assert out3 == [[0.0, 0.0], [0.0, 0.0]]\n\n    # Inconsistent lengths should raise ValueError\n    try:\n        calculate_covariance_matrix([[1, 2], [3]])\n        raise AssertionError(\"Expected ValueError for inconsistent lengths\")\n    except ValueError:\n        pass\n\n    # Fewer than two observations should raise ValueError\n    try:\n        calculate_covariance_matrix([[1], [2]])\n        raise AssertionError(\"Expected ValueError for fewer than two observations\")\n    except ValueError:\n        pass\n\n    print(\"All tests passed.\")\n\n\nif __name__ == \"__main__\":\n    solution()\n",
  "timeComplexity": "O(F^2 * N), where F is the number of features and N is the number of observations",
  "spaceComplexity": "O(F * N) for the centered data and O(F^2) for the covariance matrix",
  "platform": "deepml"
};
