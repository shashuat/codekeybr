import { Problem } from '../../types';

export const DM_119_SOLVE_SYSTEM_OF_LINEAR_EQUATIONS_USING_CRAMER_S_RULE: Problem = {
  "id": "dm_119_solve_system_of_linear_equations_using_cramers_rule",
  "title": "Solve System of Linear Equations Using Cramer's Rule",
  "difficulty": "Medium",
  "tags": [
    "Linear Algebra",
    "Matrix Operations"
  ],
  "descriptionMarkdown": "Implement a function to solve a system of linear equations Ax = b using Cramer's Rule.\n\nRequirements:\n- Input: a square coefficient matrix A and a constant vector b\n- Output: the solution vector x\n- If det(A) = 0 (no unique solution), return -1\n\nExample:\n- Input:\n  - A = [[2, -1, 3], [4, 2, 1], [-6, 1, -2]]\n  - b = [5, 10, -3]\n- Output: [0.1667 3.3333 2.6667]\n\nNotes:\n- Use determinants according to Cramer's Rule by replacing each column of A with b and computing the determinant of the modified matrix.\n- Use PyTorch for all computations.",
  "solutionExplanation": "Cramer's Rule provides a closed-form solution for a linear system Ax = b when the coefficient matrix A is square and invertible (i.e., det(A) \u2260 0). The solution for each component x_i is given by x_i = det(A_i) / det(A), where A_i is the matrix obtained by replacing the i-th column of A with the vector b.\n\nThe algorithm proceeds as follows: compute det(A). If it is zero (or sufficiently close to zero), the system has no unique solution and we return -1. Otherwise, for each column i, form A_i by cloning A and substituting column i with b, compute det(A_i), and set x_i = det(A_i) / det(A). Using double precision (float64) improves numerical stability for determinant computations.\n\nThis approach is straightforward but computationally expensive for large matrices because it requires n+1 determinant computations. It is best suited for small systems or educational purposes rather than large-scale numerical linear algebra tasks.",
  "solutionCode": "import torch\nimport torch.nn as nn\n\ndef cramers_rule(A, b, atol: float = 1e-12):\n    \"\"\"\n    Solve Ax = b using Cramer's Rule.\n\n    Parameters:\n        A (array-like or torch.Tensor): Square coefficient matrix of shape (n, n).\n        b (array-like or torch.Tensor): Constant vector of shape (n,) or (n, 1).\n        atol (float): Absolute tolerance to consider determinant as zero.\n\n    Returns:\n        torch.Tensor: Solution vector x of shape (n,) if det(A) != 0.\n        int: -1 if the system has no unique solution (det(A) == 0).\n    \"\"\"\n    # Convert inputs to double precision tensors for numerical stability\n    A = torch.as_tensor(A, dtype=torch.float64)\n    b = torch.as_tensor(b, dtype=torch.float64).flatten()\n\n    # Validate shapes\n    if A.dim() != 2:\n        raise ValueError(\"A must be a 2D square matrix.\")\n    n, m = A.shape\n    if n != m:\n        raise ValueError(\"A must be square (n x n).\")\n    if b.numel() != n:\n        raise ValueError(\"b must have the same number of elements as A has rows.\")\n\n    # Compute determinant of A\n    detA = torch.linalg.det(A)\n    if torch.isclose(detA, torch.tensor(0.0, dtype=torch.float64), atol=atol):\n        return -1\n\n    # Compute each component using Cramer's Rule\n    x = torch.empty(n, dtype=torch.float64)\n    for i in range(n):\n        Ai = A.clone()\n        Ai[:, i] = b\n        detAi = torch.linalg.det(Ai)\n        x[i] = detAi / detA\n\n    return x\n\n\ndef solution():\n    # Example usage\n    A = [[2, -1, 3], [4, 2, 1], [-6, 1, -2]]\n    b = [5, 10, -3]\n\n    torch.set_printoptions(precision=4, sci_mode=False)\n    x = cramers_rule(A, b)\n    if isinstance(x, int) and x == -1:\n        print(-1)\n    else:\n        print(x)\n\n# If you want to run the example directly, uncomment the following line:\n# solution()\n",
  "timeComplexity": "O(n^4)",
  "spaceComplexity": "O(n^2)",
  "platform": "deepml"
};
