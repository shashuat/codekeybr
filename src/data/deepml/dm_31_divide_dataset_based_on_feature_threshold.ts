import { Problem } from '../../types';

export const DM_31_DIVIDE_DATASET_BASED_ON_FEATURE_THRESHOLD: Problem = {
  "id": "dm_31_divide_dataset_based_on_feature_threshold",
  "title": "Divide Dataset Based on Feature Threshold",
  "difficulty": "Medium",
  "tags": [
    "Matrix Operations",
    "Linear Algebra"
  ],
  "descriptionMarkdown": "Write a function that divides a dataset based on whether the value of a specified feature (column) is greater than or equal to a given threshold. The function should return two subsets: one containing the samples that meet the condition, and another containing the samples that do not.\n\nExample:\n\nInput:\n\nX = [[1, 2],\n [3, 4],\n [5, 6],\n [7, 8],\n [9, 10]]\nfeature_i = 0\nthreshold = 5\n\nOutput:\n\n[[[ 5,  6],\n  [ 7,  8],\n  [ 9, 10]],\n [[1, 2],\n  [3, 4]]]\n\nReasoning: The dataset X is divided based on whether the value in the 0th feature (first column) is greater than or equal to 5. Samples with the first column value >= 5 are in the first subset, and the rest are in the second subset.",
  "solutionExplanation": "The task is a straightforward row-wise split based on a condition applied to a specific column. In PyTorch, we can achieve this efficiently using boolean masking. We compute a mask by comparing the chosen feature column with the threshold, resulting in a boolean tensor indicating which rows satisfy the condition.\n\nUsing this mask, we index into the original tensor to obtain two subsets: one where the condition holds (greater than or equal to the threshold) and one where it does not. This approach leverages vectorized operations, avoiding explicit Python loops and providing good performance on both CPU and GPU. The method also preserves the original tensor's dtype and device.",
  "solutionCode": "import torch\nimport torch.nn as nn\nfrom typing import Tuple\n\n\ndef divide_on_feature(X, feature_i: int, threshold) -> Tuple[torch.Tensor, torch.Tensor]:\n    \"\"\"\n    Split dataset into two subsets based on whether X[:, feature_i] >= threshold.\n\n    Args:\n        X: 2D array-like (torch.Tensor, numpy array, or list) of shape (N, D).\n        feature_i: Index of the feature/column to compare.\n        threshold: Scalar numeric threshold for comparison.\n\n    Returns:\n        A tuple (ge_subset, lt_subset):\n            - ge_subset: Rows where X[:, feature_i] >= threshold\n            - lt_subset: Rows where X[:, feature_i] < threshold\n    \"\"\"\n    # Convert input to a torch.Tensor without unnecessary copy if already a tensor\n    X_t = torch.as_tensor(X)\n\n    # Validate shape\n    if X_t.ndim != 2:\n        raise ValueError(\"X must be a 2D array/tensor of shape (N, D)\")\n\n    N, D = X_t.shape\n    if not (0 <= feature_i < D):\n        raise IndexError(f\"feature_i must be in [0, {D-1}], got {feature_i}\")\n\n    # Build a threshold tensor on the same device/dtype as the selected column for safe comparison\n    col = X_t[:, feature_i]\n    thr = col.new_tensor(threshold)\n\n    # Boolean mask for rows meeting the condition\n    mask = col >= thr\n\n    # Advanced indexing with boolean mask returns the two subsets\n    ge_subset = X_t[mask]\n    lt_subset = X_t[~mask]\n    return ge_subset, lt_subset\n\n\ndef solution():\n    # Example usage replicating the problem statement\n    X = torch.tensor([[1, 2],\n                      [3, 4],\n                      [5, 6],\n                      [7, 8],\n                      [9, 10]])\n    feature_i = 0\n    threshold = 5\n\n    ge_subset, lt_subset = divide_on_feature(X, feature_i, threshold)\n\n    # Print as a Python list of tensors to mirror the example structure\n    print([ge_subset, lt_subset])\n\n\nif __name__ == \"__main__\":\n    solution()\n",
  "timeComplexity": "O(N)",
  "spaceComplexity": "O(N)",
  "platform": "deepml"
};
