import { Problem } from '../../types';

export const DM_33_GENERATE_RANDOM_SUBSETS_OF_A_DATASET: Problem = {
  "id": "dm_33_generate_random_subsets_of_a_dataset",
  "title": "Generate Random Subsets of a Dataset",
  "difficulty": "Medium",
  "tags": [
    "Probability",
    "Matrix Operations"
  ],
  "descriptionMarkdown": "Write a Python function to generate random subsets of a given dataset.\n\n- Inputs:\n  - X: 2D numpy array (shape: n x d)\n  - y: 1D numpy array (length: n)\n  - n_subsets: integer, number of subsets to generate\n  - replacements: boolean\n  - seed: integer for reproducibility (default 42)\n\n- Behavior:\n  - If replacements is True: each subset contains n samples (same as original size) sampled with replacement.\n  - If replacements is False: each subset contains n//2 samples sampled without replacement (no repeats within a subset).\n\n- Output:\n  - A list of length n_subsets, where each element is a tuple (X_subset, y_subset). Each subset is returned as lists (not numpy arrays).\n\nExample:\n\n```\nInput:\nX = np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]])\ny = np.array([1, 2, 3, 4, 5])\nn_subsets = 3\nreplacements = False\nget_random_subsets(X, y, n_subsets, replacements, seed=42)\n\nOutput:\n[([[3, 4], [9, 10]], [2, 5]),\n ([[7, 8], [3, 4]], [4, 2]),\n ([[3, 4], [1, 2]], [2, 1])]\n```\n",
  "solutionExplanation": "We can implement sampling using PyTorch to ensure efficient, vectorized operations and reproducibility via a dedicated random number generator. For sampling without replacement, torch.randperm(n, generator=g) produces a random permutation of indices [0, ..., n-1], from which we take the first n//2 elements. For sampling with replacement, torch.randint(0, n, (n,), generator=g) draws n indices, allowing repeats by definition. Using index_select on the first dimension gathers the corresponding rows for X and elements for y.\n\nThe function first validates input shapes to ensure X is 2D and y is 1D with matching lengths. It then computes the subset size based on replacements. A torch.Generator is seeded for deterministic results across runs. Each subset is formed by sampling indices, slicing X and y with those indices, and converting the result to Python lists to match the required return format.\n",
  "solutionCode": "import torch\nimport torch.nn as nn\nfrom typing import List, Tuple, Any\n\n\ndef get_random_subsets(X: Any, y: Any, n_subsets: int, replacements: bool = True, seed: int = 42) -> List[Tuple[list, list]]:\n    \"\"\"\n    Generate random subsets of a dataset using PyTorch.\n\n    Args:\n        X: 2D numpy array or tensor of shape (n, d).\n        y: 1D numpy array or tensor of shape (n,).\n        n_subsets: Number of subsets to generate.\n        replacements: If True, sample with replacement (subset size = n). If False, sample without replacement (subset size = n//2).\n        seed: Random seed for reproducibility.\n\n    Returns:\n        List of length n_subsets, where each element is a tuple (X_subset_list, y_subset_list).\n        Each subset is converted to Python lists as required.\n    \"\"\"\n    # Convert inputs to torch tensors (no data copy if possible)\n    X_t = torch.as_tensor(X)\n    y_t = torch.as_tensor(y)\n\n    # Basic validation\n    if X_t.dim() != 2:\n        raise ValueError(\"X must be a 2D array/tensor of shape (n, d).\")\n    if y_t.dim() != 1:\n        raise ValueError(\"y must be a 1D array/tensor of shape (n,).\")\n    if X_t.size(0) != y_t.size(0):\n        raise ValueError(\"X and y must have the same number of samples (rows).\")\n\n    n = X_t.size(0)\n    subset_size = n if replacements else (n // 2)\n\n    # Create a seeded generator for reproducibility\n    g = torch.Generator()\n    g.manual_seed(int(seed))\n\n    subsets: List[Tuple[list, list]] = []\n\n    for _ in range(int(n_subsets)):\n        if replacements:\n            # With replacement: allow repeated indices\n            idx = torch.randint(low=0, high=n, size=(subset_size,), generator=g)\n        else:\n            # Without replacement: take the first subset_size indices from a random permutation\n            if subset_size > 0:\n                idx = torch.randperm(n, generator=g)[:subset_size]\n            else:\n                idx = torch.empty(0, dtype=torch.long)\n\n        # Gather subsets\n        X_subset = X_t.index_select(0, idx)\n        y_subset = y_t.index_select(0, idx)\n\n        # Convert to Python lists as required by the problem statement\n        subsets.append((X_subset.tolist(), y_subset.tolist()))\n\n    return subsets\n\n\ndef solution():\n    # Example usage matching the prompt\n    import numpy as np\n    X = np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]])\n    y = np.array([1, 2, 3, 4, 5])\n    n_subsets = 3\n    replacements = False\n    out = get_random_subsets(X, y, n_subsets, replacements, seed=42)\n    print(out)\n",
  "timeComplexity": "O(n_subsets * n) in the worst case (with replacement); O(n_subsets * (n/2)) when sampling without replacement",
  "spaceComplexity": "O(n) additional working memory per subset (excluding the output list)",
  "platform": "deepml"
};
