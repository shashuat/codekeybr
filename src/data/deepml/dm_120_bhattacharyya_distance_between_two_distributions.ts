import { Problem } from '../../types';

export const DM_120_BHATTACHARYYA_DISTANCE_BETWEEN_TWO_DISTRIBUTIONS: Problem = {
  "id": "dm_120_bhattacharyya_distance_between_two_distributions",
  "title": "Bhattacharyya Distance Between Two Distributions",
  "difficulty": "Easy",
  "tags": [
    "Probability"
  ],
  "descriptionMarkdown": "Implement a function to calculate the Bhattacharyya distance between two discrete probability distributions. The function should take two lists representing distributions p and q and return the Bhattacharyya distance rounded to 4 decimal places.\n\nRules:\n- If the inputs have different lengths or are empty, return 0.0.\n- Use the Bhattacharyya coefficient BC = sum_i sqrt(p_i * q_i), and the distance D = -log(BC).\n\nExample:\n- Input: p = [0.1, 0.2, 0.3, 0.4], q = [0.4, 0.3, 0.2, 0.1]\n- Output: 0.1166\n- Reasoning: BC = 0.8898, D = -log(0.8898) = 0.1166.",
  "solutionExplanation": "The Bhattacharyya distance measures similarity between two probability distributions. For discrete distributions p and q, it is defined via the Bhattacharyya coefficient (BC), which is the sum over elements of the square root of their element-wise product: BC = sum_i sqrt(p_i q_i). The distance is then computed as D = -log(BC). Intuitively, when p and q are similar, BC is close to 1 and the distance is small; when they are disjoint, BC approaches 0 and the distance grows.\n\nTo implement this efficiently, we convert the input lists into PyTorch tensors and use vectorized operations: element-wise multiplication, square root, summation, and a logarithm. We handle edge cases by returning 0.0 when the lists are empty or of different lengths. Finally, we round the scalar result to 4 decimal places to match the required output format.",
  "solutionCode": "import torch\n\ndef bhattacharyya_distance(p: list[float], q: list[float]) -> float:\n    \"\"\"\n    Compute the Bhattacharyya distance between two discrete probability distributions.\n    - If p and q are empty or have different lengths, return 0.0\n    - Distance D = -log(BC), where BC = sum_i sqrt(p_i * q_i)\n\n    Args:\n        p: List of non-negative floats representing a probability distribution.\n        q: List of non-negative floats representing a probability distribution.\n    Returns:\n        float: Bhattacharyya distance rounded to 4 decimals.\n    \"\"\"\n    # Validate inputs\n    if not isinstance(p, (list, tuple)) or not isinstance(q, (list, tuple)):\n        return 0.0\n    if len(p) == 0 or len(q) == 0 or len(p) != len(q):\n        return 0.0\n\n    # Convert to tensors for vectorized operations\n    p_t = torch.tensor(p, dtype=torch.float64)\n    q_t = torch.tensor(q, dtype=torch.float64)\n\n    # Compute Bhattacharyya coefficient: sum sqrt(p_i * q_i)\n    # Clamp to avoid tiny negative values under sqrt due to numerical noise\n    prod = torch.clamp(p_t * q_t, min=0.0)\n    bc = torch.sqrt(prod).sum()\n\n    bc_val = float(bc.item())\n    if bc_val <= 0.0:\n        # If BC is zero, distance is infinite (disjoint support)\n        return float('inf')\n\n    dist = -torch.log(bc).item()\n    return round(float(dist), 4)\n\n\ndef solution():\n    # Example usage\n    p = [0.1, 0.2, 0.3, 0.4]\n    q = [0.4, 0.3, 0.2, 0.1]\n    print(bhattacharyya_distance(p, q))  # Expected: 0.1166\n\n\nif __name__ == \"__main__\":\n    solution()\n",
  "timeComplexity": "O(N)",
  "spaceComplexity": "O(N)",
  "platform": "deepml"
};
