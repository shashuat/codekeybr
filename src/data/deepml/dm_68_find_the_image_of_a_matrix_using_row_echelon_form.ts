import { Problem } from '../../types';

export const DM_68_FIND_THE_IMAGE_OF_A_MATRIX_USING_ROW_ECHELON_FORM: Problem = {
  "id": "dm_68_find_the_image_of_a_matrix_using_row_echelon_form",
  "title": "Find the Image of a Matrix Using Row Echelon Form",
  "difficulty": "Medium",
  "tags": [
    "Linear Algebra",
    "Matrix Operations"
  ],
  "descriptionMarkdown": "Task: Compute the Column Space of a Matrix\n\nImplement a function `matrix_image(A)` that calculates the column space (image) of a given matrix `A`. The column space is the set of all linear combinations of the columns of `A`. To find a basis for this space, identify the independent columns of `A` using row echelon form (Gaussian elimination with row operations only). Return the basis vectors as a subset of the original columns of `A` corresponding to pivot columns.\n\nExample:\n\nInput:\n\nmatrix = [[1, 2, 3],\n          [4, 5, 6],\n          [7, 8, 9]]\n\nOutput:\n\n[[1, 2],\n [4, 5],\n [7, 8]]\n\nReasoning:\nThe column space of the matrix is spanned by the independent columns; here the first two columns are independent while the third is a linear combination of the first two. Thus, the basis extracted from the original matrix is the first two columns.",
  "solutionExplanation": "The column space (image) of a matrix A is the span of its columns. A standard way to extract a basis for this space directly from A is to perform Gaussian elimination (row operations only) to transform A to row echelon form while tracking which columns contain pivots. Row operations do not change linear dependencies among columns, so the pivot columns in echelon form correspond to a linearly independent subset of the original columns. Returning those original columns yields a basis for the column space.\n\nAlgorithm: iterate columns from left to right while advancing a pivot row index. For each column, find the row with the largest absolute value entry at or below the current pivot row, swap it into the pivot position, and eliminate entries below the pivot. If a valid pivot is found, record the column index as a pivot column and move to the next row. After processing all columns or exhausting rows, gather the corresponding original columns as the basis vectors. A small tolerance guards against numerical issues. This approach is numerically stable enough for typical inputs, especially when performed in double precision.",
  "solutionCode": "import torch\n\ndef matrix_image(A: torch.Tensor, tol: float = 1e-12) -> torch.Tensor:\n    \"\"\"\n    Compute a basis for the column space (image) of matrix A by identifying\n    pivot columns via row echelon form (using only row operations).\n\n    Args:\n        A: Tensor of shape (m, n). Will be converted to float64 for stability.\n        tol: Tolerance to treat small values as zero during pivoting.\n\n    Returns:\n        Tensor of shape (m, r) containing the r independent columns of A\n        that form a basis of the column space, extracted from the original A.\n    \"\"\"\n    if not isinstance(A, torch.Tensor):\n        A = torch.tensor(A)\n\n    # Ensure 2D\n    if A.ndim != 2:\n        raise ValueError(\"Input A must be a 2D tensor\")\n\n    m, n = A.shape\n    if m == 0 or n == 0:\n        return A[:, :0]\n\n    # Work in float64 for improved numerical stability\n    R = A.detach().clone().to(dtype=torch.float64)\n\n    pivot_cols = []\n    row = 0\n\n    for col in range(n):\n        if row >= m:\n            break\n        # Find pivot row by maximum absolute value in current column at/under 'row'\n        col_slice = R[row:, col].abs()\n        max_val, rel_idx = torch.max(col_slice, dim=0)\n\n        if torch.isnan(max_val) or max_val <= tol:\n            # No valid pivot in this column\n            continue\n\n        pivot_row = row + int(rel_idx.item())\n        # Swap rows to bring pivot into position\n        if pivot_row != row:\n            R[[row, pivot_row], :] = R[[pivot_row, row], :]\n\n        pivot = R[row, col]\n        if abs(pivot) <= tol:\n            continue\n\n        # Eliminate entries below the pivot\n        if row + 1 < m:\n            factors = R[row + 1:, col] / pivot\n            R[row + 1:, :] -= factors.unsqueeze(1) * R[row:row + 1, :]\n\n        pivot_cols.append(col)\n        row += 1\n\n    # Extract pivot columns from the original matrix (preserve original dtype)\n    result = A[:, pivot_cols] if pivot_cols else A[:, :0]\n    return result\n\n\ndef solution():\n    # Example usage\n    matrix = torch.tensor([[1., 2., 3.],\n                           [4., 5., 6.],\n                           [7., 8., 9.]])\n    basis = matrix_image(matrix)\n    print(basis)\n\nif __name__ == \"__main__\":\n    solution()\n",
  "timeComplexity": "O(m n^2)",
  "spaceComplexity": "O(m n)",
  "platform": "deepml"
};
