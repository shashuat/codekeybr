import { Problem } from '../../types';

export const DM_74_CREATE_COMPOSITE_HYPERVECTOR_FOR_A_DATASET_ROW: Problem = {
  "id": "dm_74_create_composite_hypervector_for_a_dataset_row",
  "title": "Create Composite Hypervector for a Dataset Row",
  "difficulty": "Medium",
  "tags": [
    "Linear Algebra",
    "Matrix Operations",
    "Embeddings"
  ],
  "descriptionMarkdown": "Task: Generate a Composite Hypervector Using Hyperdimensional Computing (HDC)\n\nImplement the function `create_row_hv(row, dim, random_seeds)` to generate a composite hypervector for a given dataset row using HDC.\n\nFor each feature in the row:\n- Create a hypervector for the feature name using the seed from `random_seeds`.\n- Create a hypervector for the feature value using a deterministic combination of the seed and the value.\n- Bind these two hypervectors via element-wise multiplication.\n\nThen bundle all bound feature hypervectors via element-wise sum and normalize to bipolar values (-1 or 1) using a threshold: values >= 0 map to 1, values < 0 map to -1.\n\nInput:\n- `row`: A dictionary representing a dataset row, where keys are feature names and values are their corresponding values.\n- `dim`: The dimensionality of the hypervectors.\n- `random_seeds`: A dictionary where keys are feature names and values are seeds for reproducible hypervector generation.\n\nOutput:\n- A NumPy array (composite hypervector) of shape `(dim,)` with bipolar values in {-1, 1}.\n\nKey Operations:\n- Bind: Element-wise multiplication of two hypervectors.\n- Bundle: Element-wise sum across hypervectors, then normalize (>= 0 \u2192 1, < 0 \u2192 -1).\n\nExample:\n- Input:\n  - `row = {'FeatureA': 'value1', 'FeatureB': 'value2'}`\n  - `dim = 5`\n  - `random_seeds = {'FeatureA': 42, 'FeatureB': 7}`\n- Output:\n  - `array([-1,  1,  1,  1,  1])`\n\nReasoning:\nFor each feature, we create hypervectors for the name and value, bind them together, then bundle all bound HVs. The binding (multiplication) creates a unique representation for each name\u2013value pair, and bundling (sum + normalize) combines them into a single row representation.",
  "solutionExplanation": "Hyperdimensional Computing (HDC) represents symbols (e.g., feature names and values) as dense high-dimensional random bipolar vectors (hypervectors). To encode a row of feature name\u2013value pairs, we generate two hypervectors per feature: one for the feature name (seeded by `random_seeds[name]`) and another for the feature value (using a deterministic seed derived from a combination of the feature's seed and a stable hash of the value). Binding is performed by element-wise multiplication, which preserves dimensionality while producing a unique composite for each name\u2013value pair.\n\nTo combine multiple bound hypervectors into a single row representation, we bundle them by summing across features element-wise, and then apply a bipolar thresholding step: elements with sums >= 0 map to +1 and those < 0 map to -1. This produces a robust, noise-tolerant composite hypervector.\n\nWe ensure determinism by using a torch.Generator with manual seeds for both name and value hypervectors and derive the value seed via a stable SHA-256 hash of the value string combined with the feature seed (e.g., XOR). The implementation uses pure PyTorch tensor operations and returns the final result as a NumPy array, as required.",
  "solutionCode": "import hashlib\nfrom typing import Dict, Any\n\nimport numpy as np\nimport torch\n\n\ndef _bipolar_random_hv(dim: int, seed: int) -> torch.Tensor:\n    \"\"\"\n    Generate a bipolar hypervector of length dim with values in {-1, 1}\n    using a deterministic torch.Generator seeded with `seed`.\n    \"\"\"\n    g = torch.Generator()\n    # Mask to keep seed within 63-bit range supported by PyTorch RNG\n    g.manual_seed(int(seed) & ((1 << 63) - 1))\n    hv = torch.randint(0, 2, (dim,), generator=g, dtype=torch.int8)\n    hv = hv.mul_(2).sub_((1))  # map {0,1} -> {-1,1}\n    return hv\n\n\ndef _stable_u64_from_string(s: str) -> int:\n    \"\"\"Compute a stable 64-bit unsigned integer from a string via SHA-256.\"\"\"\n    h = hashlib.sha256(s.encode(\"utf-8\")).digest()\n    return int.from_bytes(h[:8], byteorder=\"little\", signed=False)\n\n\ndef create_row_hv(row: Dict[str, Any], dim: int, random_seeds: Dict[str, int]) -> np.ndarray:\n    \"\"\"\n    Create a composite hypervector for a dataset row using HDC.\n\n    Args:\n        row: dict mapping feature name -> value\n        dim: dimensionality of hypervectors\n        random_seeds: dict mapping feature name -> integer seed\n\n    Returns:\n        numpy.ndarray of shape (dim,), bipolar values in {-1, 1}\n    \"\"\"\n    if not isinstance(row, dict):\n        raise TypeError(\"row must be a dict of feature name -> value\")\n    if not isinstance(random_seeds, dict):\n        raise TypeError(\"random_seeds must be a dict of feature name -> seed\")\n    if dim <= 0:\n        raise ValueError(\"dim must be a positive integer\")\n    if len(row) == 0:\n        # If no features, return an all-ones bipolar vector by convention\n        return np.ones((dim,), dtype=np.int8)\n\n    # Accumulator for bundling (use int32 to avoid overflow for many features)\n    sum_hv = torch.zeros(dim, dtype=torch.int32)\n\n    for feat_name, feat_val in row.items():\n        if feat_name not in random_seeds:\n            raise KeyError(f\"Missing seed for feature '{feat_name}' in random_seeds\")\n\n        name_seed = int(random_seeds[feat_name])\n        name_hv = _bipolar_random_hv(dim, name_seed)\n\n        # Deterministically derive a value seed from the feature seed and a stable hash of the value\n        val_hash = _stable_u64_from_string(str(feat_val))\n        value_seed = (name_seed ^ val_hash) & ((1 << 63) - 1)\n        value_hv = _bipolar_random_hv(dim, value_seed)\n\n        # Bind (element-wise multiplication) and bundle (accumulate sum)\n        bound = (name_hv.to(torch.int32) * value_hv.to(torch.int32))\n        sum_hv.add_(bound)\n\n    # Normalize to bipolar values: >= 0 -> 1, < 0 -> -1\n    composite_int32 = torch.where(\n        sum_hv >= 0,\n        torch.ones(dim, dtype=torch.int32),\n        -torch.ones(dim, dtype=torch.int32),\n    )\n    composite = composite_int32.to(torch.int8)\n\n    return composite.numpy()\n\n\ndef solution():\n    # Example usage\n    row = {\"FeatureA\": \"value1\", \"FeatureB\": \"value2\"}\n    dim = 5\n    random_seeds = {\"FeatureA\": 42, \"FeatureB\": 7}\n    hv = create_row_hv(row, dim, random_seeds)\n    print(hv)  # Example output: array([-1,  1,  1,  1,  1], dtype=int8)\n    return hv\n",
  "timeComplexity": "O(F * D)",
  "spaceComplexity": "O(D)",
  "platform": "deepml"
};
