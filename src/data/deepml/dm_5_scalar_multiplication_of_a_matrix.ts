import { Problem } from '../../types';

export const DM_5_SCALAR_MULTIPLICATION_OF_A_MATRIX: Problem = {
  "id": "dm_5_scalar_multiplication_of_a_matrix",
  "title": "Scalar Multiplication of a Matrix",
  "difficulty": "Easy",
  "tags": [
    "Linear Algebra",
    "Matrix Operations"
  ],
  "descriptionMarkdown": "Write a Python function that multiplies a matrix by a scalar and returns the result.\n\nExample:\n- Input: matrix = [[1, 2], [3, 4]], scalar = 2\n- Output: [[2, 4], [6, 8]]\n\nReasoning: Each element of the matrix is multiplied by the scalar.",
  "solutionExplanation": "The task is a straightforward linear algebra operation: scalar-matrix multiplication. Given a 2D matrix and a scalar, we multiply every element in the matrix by the scalar. In PyTorch, this is efficiently handled by elementwise multiplication between a tensor and a scalar, which leverages vectorized operations under the hood.\n\nTo implement this robustly, we convert the input Python list of lists into a torch.Tensor. If both the matrix elements and the scalar are integers, we preserve integer arithmetic by using an integer tensor; otherwise, we use floating-point arithmetic. After performing the multiplication, we convert the result back to a nested Python list to match the problem's expected return type. This approach ensures both correctness and efficiency.",
  "solutionCode": "import torch\nfrom typing import List, Union\n\nNumber = Union[int, float]\n\ndef _validate_matrix(matrix: List[List[Number]]) -> None:\n    if not isinstance(matrix, (list, tuple)):\n        raise TypeError(\"matrix must be a list of lists\")\n    if len(matrix) == 0:\n        return\n    if not all(isinstance(row, (list, tuple)) for row in matrix):\n        raise TypeError(\"matrix must be a list of lists\")\n    row_len = len(matrix[0])\n    for row in matrix:\n        if len(row) != row_len:\n            raise ValueError(\"All rows in the matrix must have the same length\")\n        for val in row:\n            if not isinstance(val, (int, float)) or isinstance(val, bool):\n                raise TypeError(\"Matrix elements must be int or float\")\n\n\ndef _all_ints(matrix: List[List[Number]]) -> bool:\n    for row in matrix:\n        for val in row:\n            if not isinstance(val, int) or isinstance(val, bool):\n                return False\n    return True\n\n\ndef scalar_multiply(matrix: List[List[Number]], scalar: Number) -> List[List[Number]]:\n    \"\"\"\n    Multiply a 2D matrix (list of lists) by a scalar using PyTorch.\n\n    Args:\n        matrix: List of lists containing ints or floats.\n        scalar: A numeric scalar (int or float).\n\n    Returns:\n        A new matrix (list of lists) with each element multiplied by the scalar.\n    \"\"\"\n    _validate_matrix(matrix)\n    if not isinstance(scalar, (int, float)) or isinstance(scalar, bool):\n        raise TypeError(\"scalar must be an int or float\")\n\n    # Choose dtype: preserve integer arithmetic only when both inputs are integers\n    use_int = _all_ints(matrix) and isinstance(scalar, int)\n    dtype = torch.int64 if use_int else torch.float32\n\n    # Create tensor and perform vectorized scalar multiplication\n    t = torch.tensor(matrix, dtype=dtype)\n    result = t * (scalar if use_int else float(scalar))\n\n    # Return as a nested Python list to match the problem specification\n    return result.tolist()\n\n\ndef solution(matrix: List[List[Number]], scalar: Number) -> List[List[Number]]:\n    \"\"\"Wrapper function required by the platform.\"\"\"\n    return scalar_multiply(matrix, scalar)\n\n\nif __name__ == \"__main__\":\n    # Example usage\n    matrix = [[1, 2], [3, 4]]\n    scalar = 2\n    print(\"Input matrix:\", matrix)\n    print(\"Scalar:\", scalar)\n    out = scalar_multiply(matrix, scalar)\n    print(\"Output matrix:\", out)  # Expected: [[2, 4], [6, 8]]\n",
  "timeComplexity": "O(N)",
  "spaceComplexity": "O(N)",
  "platform": "deepml"
};
